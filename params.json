{"tagline":"HTTL是一个适用于HTML输出的开源JAVA模板引擎.","note":"Don't delete this file! It's used internally to help with page regeneration.","body":"# 1. 概述\r\n\r\nHTTL是一个适用于HTML输出的开源JAVA模板引擎，可用于替代JSP页面，它的指令类似于Velocity\u001D。 \r\n\r\n### 快速\r\n类似于JSP的原理，将模板编译成Java字节码运行，但比JSP的EL更进一步，使用强类型推导，减少运行期反射和转型，更加快速，请参见下面的性能对比.\r\n\r\n### 简洁\r\n保持最简洁指令集，只保留基本的占位/注释/转义，和八个必需的控制指令，其它都降级为表达式方法实现，比如$!{include(\"a.httl\")}。\r\n\r\n### 直觉\r\n语法尽可能符合HTML和JAVA开发者的直觉，指令类似于常用Velocity指令，但改进了Velocity中不符合直觉的地方，请参见下面与Velocity的对比。\r\n\r\n### 友好\r\n模板自描述，在模板内声明入参变量类型，并基于入参类型推导模板内所有变量类型，使IDE能方便的实现变量方法补全提示，对开发过程友好。\r\n \r\n# 2. 对比\r\n\r\n如果你用过Velocity模板，可以查看以下对比，加深了解：\r\n\r\n## 2.1 语法对比 \r\n\r\n1. HTTL指令必需加注释外壳，只支持&lt;!--#if(x)--&gt;，不支持#if(x)，确保不干扰HTML本身的有效源码。 \r\n\r\n2. HTTL指令中的变量不加$符，只支持&lt;!--#foreach(book in books)--&gt;，不支持&lt;!--#foreach($book in $books)--&gt;，因为指令中没有加引号的字符串就是变量，和常规语言的语法一样，加$有点废话。 \r\n\r\n3. HTTL占位符必需加大括号，只支持${aaa}，不支持$aaa，因为$在JavaScript中也是合法变量名符号，而${}不是，减少混淆，也防止多人开发时，有人加大括号，有人不加，干脆没得选，都加，保持一致。 \r\n\r\n4. HTTL占位符当变量为null时输出空白串，而不像Velocity那样原样输出指令原文，即${aaa}，等价于Velocity的$!{aaa}，以免开发人员忘写感叹号，泄漏表达式源码，如需原样输出，可使用转义\\${aaa}，\r\n在HTTL中，$!{aaa}表示不对内容进行过滤，用于原样输出HTML片段。\r\n\r\n5. HTTL支持在所有使用变量的地方，进行表达式计算，也就是你不需要像Velocity那样，先#set($j = $i + 1)，再#if($j == $m)，可以直接&lt;!--#if(i + 1 == $m)--&gt;，其它指令也一样。\r\n\r\n6. HTTL采用扩展Class原生方法的方式，如：${\"a\".toChar}，而不像Velocity的Tool工具方法那样：$(StringTool.toChar(\"a\"))，这样的调用方式更直观，更符合代码书写习惯。\r\n\r\n## 2.2 指令对比\r\n\r\n<table>\r\n<tr><td>HTTL</td><td>Velocity</td><td>异同</td><td>功能</td></tr>\r\n<tr><td>${xxx.yyy}</td><td>$xxx.yyy<br/>${xxx.yyy}</td><td>相同</td><td>输出占位符</td></tr>\r\n<tr><td>$!{xxx.yyy}</td><td>$!xxx.yyy<br/>$!{xxx.yyy}</td><td>不同</td><td>一个是不过滤，一个是不原样输出</td></tr>\r\n<tr><td>&lt;!--## ... --&gt;</td><td>## ...<br/>#* ... *#</td><td>相似</td><td>不显示注释块</td></tr>\r\n<tr><td>&lt;![CDATA[## ... ]]&gt;</td><td>#[[ ... ]]#</td><td>相似</td><td>不解析文本块</td></tr>\r\n<tr><td>\\# \\$ \\\\</td><td>\\# \\$ \\\\</td><td>相同</td><td>特殊符转义</td></tr>\r\n<tr><td>&lt;!--#var(Xxx xxx)--&gt;</td><td>不支持</td><td>不同</td><td>定义输入参数类型</td></tr>\r\n<tr><td>&lt;!--#set(xxx = yyy)--&gt;</td><td>#set($xxx = $yyy)</td><td>相同</td><td>给变量赋值</td></tr>\r\n<tr><td>&lt;!--#if(xxx == yyy)--&gt;</td><td>#if($xxx == $yyy)</td><td>相同</td><td>条件判断</td></tr>\r\n<tr><td>&lt;!--#elseif(xxx == yyy)--&gt;</td><td>#elseif($xxx == $yyy)</td><td>相同</td><td>否则条件判断</td></tr>\r\n<tr><td>&lt;!--#else--&gt;</td><td>#else</td><td>相同</td><td>否则判断</td></tr>\r\n<tr><td>&lt;!--#end--&gt;</td><td>#end</td><td>相同</td><td>结束指令</td></tr>\r\n<tr><td>&lt;!--#foreach(item in list)--&gt;</td><td>#foreach($item in $list)</td><td>相同</td><td>列表循环</td></tr>\r\n<tr><td>&lt;!--#breakif(xxx == yyy)--&gt;</td><td>#if($xxx == $yyy) #break #end</td><td>相似</td><td>中断循环</td></tr>\r\n<tr><td>&lt;!--#macro(xxx)--&gt;</td><td>#macro($xxx)</td><td>相似</td><td>宏替换，模板片断</td></tr>\r\n<tr><td>&lt;!--#set(xxx=xxxmacro())--&gt;</td><td>#define($xxx)</td><td>相似</td><td>捕获块输出到变量中</td></tr>\r\n<tr><td>$!{read(\"xxx.txt\")}</td><td>#include(\"xxx.txt\")</td><td>相似</td><td>读取文本文件内容</td></tr>\r\n<tr><td>$!{include(\"xxx.httl\")}</td><td>#parse(\"xxx.vm\")</td><td>相似</td><td>包含另一模板输出</td></tr>\r\n<tr><td>$!{evaluate(\"1 + 2\")}</td><td>#evaluate(\"1 + 2\")</td><td>相似</td><td>表达式求值</td></tr>\r\n<tr><td>不支持</td><td>#stop</td><td>不同</td><td>停止模板解析</td></tr>\r\n</table>\r\n\r\n## 2.3 性能对比\r\n\r\n<table>\r\n<tr><td>引擎</td><td>版本</td><td>初始化</td><td>编译</td><td>首渲染</td><td>万次渲染</td><td>每秒次数</td></tr>\r\n<tr><td>Freemarker</td><td> 2.3.18</td><td> 79ms</td><td>125ms</td><td> 78ms</td><td>16,934ms</td><td>590/s</td><</tr>\r\n<tr><td>Velocity</td><td> 1.7</td><td> 31ms</td><td>110ms</td><td> 31ms</td><td>19,278ms</td><td>518/s</td></tr>\r\n<tr><td>Smarty4j</td><td> 1.0.0-jdk5</td><td> 0ms</td><td>78ms</td><td> 0ms</td><td>21,653ms</td><td>461/s</td></tr>\r\n<tr><td>Httl</td><td> 0.1.0</td><td> 78ms</td><td>547ms</td><td> 0ms</td><td>2,077ms</td><td>4,814/s</td></tr>\r\n<tr><td>Java</td><td> 1.6.0_18</td><td> 0ms</td><td>0ms</td><td> 0ms</td><td>2,016ms</td><td>4,960/s</td></tr>\r\n</table>\r\n\r\n## 2.4 优化策略\r\n\r\n### 2.4.1 强类型编译，并推导关联类型\r\n\r\n对于表达式${user.name}的编译：\r\n\r\n弱类型字节码生成：\r\n\r\n```java\r\nObject user = context.get(\"user\"); // 无法确定user是Map还是POJO\r\n// 反射获取属性的值，而且要运行期判断是user.getName()，还是user.name字段\r\nObject name = ReflectUtil.get(user, \"name\"); // 接下来name也要反射\r\n```\r\n\r\nHTTL强类型字节码生成：\r\n\r\n```java\r\nUser user = (User)context.get(\"user\"); // 通过in=\"User user\"声明类型\r\nString name = user.getName(); // 编译期通过User的字段类型推演name的类型，并在编译期决定使用getName()\r\n```\r\n\r\n### 2.4.2 编译时就将文本编译成字节，加快输出\r\n\r\n文本编译：\r\n\r\n```java\r\nwriter.write(\"<table><tr><td>\");\r\nwriter.write(user.getName());\r\n```\r\n\r\n当在httl.properties中配置了：\r\n```properties\r\noutput.stream=true\r\n```\r\n\r\nHTTL将编译成二进制：\r\n\r\n```java\r\nprivate static byte[] final _B1_ = new byte[] {60, 116, 97, 98, 108, 101, 62, 60, 116, 114, 62, 60, 116, 100, 62};\r\noutput.write(_B1_);\r\noutput.write(user.getName().getBytes());\r\n```\r\n\r\n这样可以大幅度降低IO输出时将文本通过字符集编码成二进制流的速度。\r\n\r\n### 2.4.3 对于赋值生成局部变量，不put回参数map\r\n\r\n比如：set=\"price = price * discount / 100\"编译：\r\n\r\n```java\r\nint price = price * discount / 100;\r\nwrite(price);\r\n```\r\n\r\n而不是：\r\n\r\n```java\r\ncontext.put(\"price\", price * discount / 100);\r\nwrite(context.get(\"price\"));\r\n```\r\n\r\n这样可以大量减少参数map的put和get的调用。\r\n\r\n### 2.4.4 将文本不编译到字节码中，减少内存perm区占用，以及防止JIT失效：\r\n\r\n当模板的内容较大时，会导致生成的字节码也比较大，字节码运行时会放在内存perm区，导致perm区过大。\r\n模板多时，用户可能需要不断调大perm区：java -XX:PermSize=256MB -XX:MaxPermSize=256MB\r\n\r\n另外，SunJDK缺省对大于5K字节码的方法不进行JIT优化，我们常规开启的JVM是mixed模式的，\r\n即调用量大的，将由JIT编译成本地码运行，其它在JVM内解释执行，解释执行和编译执行的速度相差10倍以上。\r\n\r\n通过将文本不编译到字节码中，减少内存perm区占用，也能防止JIT失效。\r\n\r\n### 2.4.5 减少反射调用，以及基本类型装箱。[/b]\r\n\r\n因为模板输出的大量是基本类型和字符串，\r\n比如当输出基本类型时，需要转成String，如果使用format(Object)接口，就会将基本类型装箱，\r\nHttl遇到任何类似需要boxed和unboxed的地方，都会重载所有基本类型方法，以减少boxed和unboxed的处理。\r\n比如：有一次Profiler分析就发现，有一个地方为了能通用处理Object[],int[],long[]等数组类型，\r\n因为int[]不继承于Object[]，为了通用处理，改为Array.get(array, index)来获取数组的项，\r\n导致Profiler时，80%的CPU时间都耗在Array.get()上。\r\n\r\n等等。\r\n\r\n# 3. 示例\r\n\r\n## 3.1 调用示例\r\n\r\nBooksServlet.java:\r\n\r\n```java\r\nimport httl.*;\r\nimport java.util.*;\r\n\r\nMap<String, Object> parameters = new HashMap<String, Object>();\r\nparameters.put(\"user\", user);\r\nparameters.put(\"books\", books);\r\n\r\nEngine engine = Engine.getEngine();\r\nTemplate template = engine.getTemplate(\"books.httl\");\r\ntemplate.render(parameters, response.getWriter());\r\n```\r\n\r\n## 3.2 模板示例\r\n\r\nbooks.httl:\r\n\r\n```html\r\n<!--#var(User user, List<Book> books)-->\r\n<html>\r\n  <body>\r\n    <!--#if(user.role == \"admin\")-->\r\n    <table>\r\n      <!--#foreach(book in books)-->\r\n      <tr>\r\n        <td>${book.title}</td>\r\n      </tr>\r\n      <!--#end-->\r\n    </table>\r\n    <!--#end-->\r\n  </body>\r\n</html>\r\n```\r\n\r\n## 3.3 配置示例\r\n\r\nhttl.properties:\r\n\r\n```properties\r\nimport.packages+=com.xxx\r\ntemplate.directory=\r\ninput.encoding=UTF-8\r\noutput.encoding=UTF-8\r\n```\r\n\r\n其中，+=表示追加配置，而不覆盖缺省配置。\r\n注意，所有配置项都有缺省值，如果使用缺省值，可以不配，\r\n更多配置参见文档下面的配置参考手册。\r\n\r\n# 4. 下载\r\n\r\n## 4.1 发布包:\r\n\r\n<https://github.com/httl/httl/downloads>\r\n\r\n## 4.2 源代码:\r\n\r\n<https://github.com/httl/httl>\r\n\r\n下载源码：\r\n\r\n```bash\r\ngit clone https://github.com/httl/httl.git\r\n```\r\n\r\n编译源码：\r\n\r\n```bash\r\nmvn install -Dmaven.test.skip\r\n```\r\n\r\n性能测试：\r\n\r\n```bash\r\nmvn test -Dtest=httl.test.PerformanceTest\r\n```\r\n\r\n生成Eclipse工程描述文件:\r\n\r\n```bash\r\nmvn eclipse:eclipse -DdownloadSources\r\n```\r\n\r\n导入Eclipse工程：\r\n\r\nEclipse -> File -> Import -> Existing Projects into Workspace -> Browse -> Finished\r\n\r\n将.httl文件以html编辑器格式打开：\r\n\r\nEclipse -> Window -> Preferences -> General -> Content Types -> Text -> HTML -> Add -> .httl\r\n\r\n## 4.3 Maven依赖:\r\n\r\n```xml\r\n<project>\r\n    <dependencies>\r\n        <dependency>\r\n            <groupId>httl</groupId>\r\n            <artifactId>httl</artifactId>\r\n            <version>0.3.0</version>\r\n            </dependency>\r\n    </dependencies>\r\n    <repositories>\r\n        <repository>\r\n            <id>httl-repository</id>\r\n            <name>Httl Repository</name>\r\n            <url>http://httl.github.com/maven/</url>\r\n        </repository>\r\n    </repositories>\r\n<project>\r\n```\r\n\r\n# 5. 模板语法\r\n\r\n基于Velocity指令和Html注释:\r\n\r\n## 5.1 输出指令\r\n\r\n### 5.1.1 过滤输出\r\n\r\n输出表达式的计算结果，并进行过滤，比如：过滤变量中的HTML标签，防止HTML注入攻击。\r\n\r\n```xml\r\n格式：\r\n${expression}\r\n\r\n示例：\r\n${user.name}\r\n```\r\n\r\n### 5.1.2 不过滤输出\r\n\r\n原样输出表达式的计算结果，不进行任何过滤，通常用于输出HTML片段。\r\n\r\n```xml\r\n格式：\r\n$!{expression}\r\n\r\n示例：\r\n$!{body}\r\n```\r\n\r\n### 5.2 变量定义指令\r\n\r\n### 5.2.1 类型声明\r\n\r\n声明输入变量的类型，模板内部其它变量类型基于此类型推导。\r\n\r\n```xml\r\n格式：\r\n<!--#var(type name, type name)-->\r\n\r\n示例：\r\n<!--#var(User user, Book[] books)-->\r\n```\r\n\r\n### 5.2.2 变量赋值\r\n\r\n将表达式的计算结果存入变量中。\r\n\r\n```xml\r\n格式：\r\n<!--#set(type name = expression)-->\r\n\r\n示例：\r\n<!--#set(price = book.price * book.discount)-->\r\n```\r\n\r\n## 5.3 条件指令\r\n\r\n### 5.3.1 IF条件\r\n\r\n如果条件表达式计算结果为真或非空，则输出指令所包含的块。\r\n\r\n```xml\r\n格式：\r\n<!--#if(expression)-->\r\n\r\n示例：\r\n<!--#if(user.role == \"admin\")-->\r\n    ...\r\n<!--#end-->\r\n```\r\n\r\n### 5.3.2 ELSEIF条件\r\n\r\n如果前面的IF条件不为真，并且当前条件表达式计算结果为真或非空，则输出指令所包含的块。\r\n\r\n```xml\r\n格式：\r\n<!--#elseif(expression)-->\r\n\r\n示例：\r\n<!--#if(user.role == \"admin\")-->\r\n    ...\r\n<!--#elseif(user.role == \"member\")-->\r\n    ...\r\n<!--#end-->\r\n```\r\n\r\n### 5.3.3 ELSE条件\r\n\r\n如果前面的IF条件不为真，则输出指令所包含的块。\r\n\r\n```xml\r\n格式：\r\n<!--#else-->\r\n\r\n示例：\r\n<!--#if(user.role == \"admin\")-->\r\n    ...\r\n<!--#else-->\r\n    ...\r\n<!--#end-->\r\n```\r\n\r\n## 5.4 迭代指令\r\n\r\n### 5.4.1 集合迭代\r\n\r\n迭代表达式产生的集合，以集合中的每项值，重复输出指令所包含的块。\r\n\r\n```xml\r\n格式：\r\n<!--#foreach(name in expression)-->\r\n\r\n示例：\r\n<!--#foreach(book in books)-->\r\n    ...\r\n    ${foreach.index}\r\n    ${foreach.size}\r\n    ${foreach.first}\r\n    ${foreach.last}\r\n<!--#end-->\r\n```\r\n\r\n### 5.4.3 中断迭代\r\n\r\n当条件表达式为真或非空时，中断当前迭代过程。\r\n\r\n```xml\r\n格式：\r\n<!--#breakif(expression)-->\r\n\r\n示例：\r\n<!--#foreach(book in books)-->\r\n    ...\r\n    <!--#breakif(foreach.index == 10)-->\r\n    ...\r\n<!--#end-->\r\n```\r\n\r\n## 5.5 宏指令\r\n\r\n将指令块封装成可复用的模板片断，在声明处不执行，在调用时再执行。\r\n\r\n```xml\r\n格式：\r\n<!--#macro(name(type name, type name))-->\r\n\r\n示例：\r\n<!--#macro(xxx(Book[] books))-->\r\n    ...\r\n<!--#end-->\r\n$!{xxx(books)}\r\n```\r\n\r\n## 5.6 字面指令\r\n\r\n### 5.6.1 注释块\r\n\r\n隐藏注释的内容，用于注解过程，或屏蔽指令内容。\r\n\r\n```xml\r\n格式：\r\n<!--## content -->\r\n\r\n示例：\r\n<!--## This is menu -->\r\n```\r\n\r\n### 5.6.2 不解析块\r\n\r\n原样输出模板内容，用于输出纯文本内容。\r\n\r\n```xml\r\n格式：\r\n<![CDATA[## content ]]>\r\n\r\n示例：\r\n<![CDATA[## This is menu ]]>\r\n```\r\n\r\n### 5.6.3 特殊符转义\r\n\r\n原样输出指令特殊符，用于输出纯文本内容。\r\n\r\n```xml\r\n格式：\r\n\\#, \\$, \\\\\r\n\r\n示例：\r\n<!--\\#xxx -->\r\n\\${xxx}\r\n```\r\n\r\n# 6. 表达式语法\r\n\r\n基于Java表达式和扩展方法。\r\n\r\n支持Java所有表达式，以下只列出与Java不同的点：\r\n\r\n* 所有null值的操作均返回null。\r\n* 所有实现Comparable的对象都支持比较运算符。\r\n* 所有对象都支持逻辑与或，分别返回空值或非空值。\r\n\r\n## 6.1 操作符表达式\r\n\r\n### 6.1.1 集合操作符\r\n\r\n```java\r\nSequence: 1..3\r\nList: [123, \"abc\"]\r\nMap: [\"xxx\": 123, \"yyy\": \"abc\"]\r\n```\r\n\r\n### 6.1.2 日期操作符\r\n\r\n```java\r\ndate1 > date2\r\ndate1 >= date2\r\ndate1 < date2\r\ndate1 <= date2\r\n```\r\n\r\n### 6.1.3 逻辑操作符\r\n\r\n```xml\r\n<!--#if(object)-->\r\n<!--#if(object != null)-->\r\n<!--#if(string)-->\r\n<!--#if(string!= null && string.length() > 0)-->\r\n<!--#if(list)-->\r\n<!--#if(list != null && list1.size() > 0)-->\r\n\r\n<!--#foreach(item in list1 || list2)-->\r\n<!--#foreach(item in list1 != null && list1.size() > 0 ? list1 : list2)-->\r\n```\r\n\r\n## 6.2 函数表达式\r\n\r\n### 6.2.1 转型函数\r\n\r\n```java\r\nobj.to(\"com.foo.Bar\")\r\nnum.toDate\r\nstr.toDate\r\nstr.toDate(\"yyyy-MM-dd HH:mm:ss\")\r\nstr.toChar\r\nstr.toBoolean\r\nstr.toByte\r\nstr.toInt\r\nstr.toLong\r\nstr.toFloat\r\nstr.toDouble\r\nstr.toClass\r\n```\r\n\r\n### 6.2.2 转义函数\r\n\r\n```java\r\nstr.escapeHtml\r\nstr.escapeUrl\r\nstr.escapeString\r\n```\r\n\r\n### 6.2.3 格式化函数\r\n\r\n```java\r\nnum.format(\"###,##0\")\r\nnum.format(\"###,##0.##\")\r\ndate.format(\"yyyy-MM-dd\")\r\ndate.format(\"yyyy-MM-dd HH:mm:ss\")\r\n```\r\n\r\n### 6.2.4 集合函数\r\n\r\n```xml\r\narray[index]\r\nlist[index]\r\n\r\nmap.key\r\nmap[\"key\"]\r\n\r\n<!--#foreach(item in array)-->\r\n${item.xxx}\r\n<!--#end-->\r\n\r\n<!--#foreach(item in list)-->\r\n${item.xxx}\r\n<!--#end-->\r\n\r\n<!--#foreach(entry in map)-->\r\n${entry.key}\r\n${entry.value}\r\n<!--#end-->\r\n\r\nsort(list)\r\n<!--#foreach(item in sort(list))-->\r\n<!--#end-->\r\n\r\ncycle(item, item)\r\n<!--#set(colors = cycle(\"red\", \"blue\", \"green\"))-->\r\n${colors.next}\r\n```\r\n\r\n### 6.2.5 文件函数\r\n\r\n```java\r\ninclude(\"template.httl\")}\r\ninclude(\"template.httl\", \"UTF-8\")\r\ninclude(locale(\"i18n-template.httl\"))\r\n\r\nread(\"text.txt\")\r\nread(\"text.txt\", \"UTF-8\")\r\nread(locale(\"i18n-text.txt\"))\r\n```\r\n\r\n### 6.2.6 系统函数\r\n\r\n```java\r\nnow()\r\nrandom()\r\nuuid()\r\n```\r\n\r\n# 7. 详细配置\r\n\r\n```properties\r\n#extensions\r\nengine=httl.spi.engines.DefaultEngine\r\nlogger=httl.spi.loggers.Log4jLogger\r\nloggers=httl.spi.loggers.Log4jLogger\r\ncache=httl.spi.caches.StrongCache\r\nloader=httl.spi.loaders.ClasspathLoader\r\nparser=httl.spi.parsers.CommentParser\r\ntranslator=httl.spi.translators.DfaTranslator\r\ncompiler=httl.spi.compilers.JdkCompiler\r\nformatter=httl.spi.formatters.MultiFormatter\r\nformatters=httl.spi.formatters.DateFormatter\r\nvalue.filter=httl.spi.filters.MultiValueFilter\r\nvalue.filters=httl.spi.filters.EscapeHtmlFilter\r\ntext.filter=httl.spi.filters.MultiTextFilter\r\ntext.filters=\r\nfilters=\r\n\r\n#properties\r\nimport.packages=java.util\r\nimport.methods=httl.spi.methods.DefaultMethod\r\nimport.macros=\r\ntemplate.directory=\r\ntemplate.suffix=.httl\r\nattribute.namespace=\r\ncache.capacity=0\r\nreloadable=false\r\nprecompiled=false\r\nsource.in.class=false\r\ntext.in.class=false\r\ndebug=false\r\ncompile.directory=\r\njava.version=1.6\r\nforeach.status=foreach\r\ninput.encoding=UTF-8\r\noutput.encoding=UTF-8\r\noutput.stream=false\r\nlocale=en_US\r\ntime.zone=+0\r\ndate.format=yyyy-MM-dd HH:mm:ss\r\nnumber.format=###,##0.###\r\nnull.value=\r\ntrue.value=true\r\nfalse.value=false\r\nsequences=Mon Tue Wed Thu Fri Sat Sun Mon,\\\r\nMonday Tuesday Wednesday Thursday Friday Saturday Sunday Monday,\\\r\nJan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec Jan,\\\r\nJanuary February March May June July August September October November December January\r\n```\r\n\r\n# 7. 设计\r\n\r\n## 7.1 类关系\r\n\r\n![ClassDiagram](http://httl.googlecode.com/svn/trunk/httl-doc/httl-class-diagram.jpg)\r\n\r\n分包原则：按复用的粒度分包，如果某些类总是一起被复用，则放在一个包下面。 \r\n\r\nHTTL有两种用户： \r\n\r\n1. 一种是模板引擎的使用者， \r\n\r\n2. 一种是模板引擎的扩展者。 \r\n\r\n每种用户所需用到的类，就是同一复用粒度的。 \r\n\r\n所以在整体上划分为三层： \r\n\r\n1. API (Application Programming Interface) 直接使用者需要导入的接口。\r\n \r\n2. SPI (Service Provider Interface)  扩展者需要导入的接口。 \r\n\r\n3. Impl (Built-in Implementation) 内置扩展实现。 \r\n\r\n使用者API导入： \r\n\r\n```java\r\nimport httl.*;  \r\n```\r\n\r\n扩展者SPI导入： \r\n\r\n```java\r\nimport httl.spi.*;\r\n```\r\n\r\n## 7.2 调用过程\r\n\r\n![Sequence diagram](http://httl.googlecode.com/svn/trunk/httl-doc/httl-sequence-diagram.jpg)\r\n\r\n执行过程说明：(与上图中的序号对应) \r\n\r\n1. 当从引擎中获取模板时， \r\n\r\n2. 首先会在缓存查找是否已缓存，如果有缓存就直接返回， \r\n\r\n3. 如果没有，则加载模板， \r\n\r\n4. 接着进行模板语法解析， \r\n\r\n5. 在解析到表达式时，将其转译为Java表达式， \r\n\r\n6. 并对静态文本进行编译前过滤，比如删除空白等， \r\n\r\n7. 对解析后的Java代码进行编译，得到Template的具体模板实现类， \r\n\r\n8. 实例化模板实现类， \r\n\r\n9. 将模板实例写入缓存，并返回给用户， \r\n\r\n10. 当用户调用模板的渲染方法时， \r\n\r\n11. 将静态模板文本直接输出， \r\n\r\n12. 将动态占位符内容，先格式化成字符串， \r\n\r\n13. 再进行过滤，比如转义动态内容的HTML特殊符，\r\n \r\n14. 然后输出过滤后的内容。 ","name":"<HTTL/>","google":""}