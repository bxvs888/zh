{"note":"Don't delete this file! It's used internally to help with page regeneration.","body":"# 1. 概述\r\n\r\nHTTL是一个适用于HTML输出的开源JAVA模板引擎，可用于替代JSP页面，它的指令和Velocity相似\u001D。 \r\n\r\n### 快速\r\n类似于JSP的原理，将模板编译成Java字节码运行，但比JSP的EL更进一步，使用强类型推导，减少运行期反射和转型，更加快速，请参见第2章的性能对比.\r\n\r\n### 简洁\r\n保持最简洁指令集，只保留基本的占位/注释/转义，和八个必需的控制指令，其它都降级为表达式方法实现，比如$!{include(\"a.httl\")}。\r\n\r\n### 直觉\r\n语法尽可能符合HTML和JAVA开发者的直觉，指令类似于常用Velocity指令，但改进了Velocity中不符合直觉的地方，请参见第2章与Velocity的对比。\r\n\r\n### 友好\r\n模板自描述，在模板内声明入参变量类型，并基于入参类型推导模板内所有变量类型，使IDE能方便的实现变量方法补全提示，对开发过程友好。\r\n \r\n# 2. 对比\r\n\r\n## 2.1 性能对比\r\n\r\n性能测试类：[PerformanceTest.java](https://github.com/httl/httl/blob/master/src/test/java/httl/test/PerformanceTest.java)\r\n\r\n<table>\r\n<tr>\r\n<td>引擎</td>\r\n<td>模板</td>\r\n<td>初始化</td>\r\n<td>编译</td>\r\n<td>首渲染</td>\r\n<td>十万渲染</td>\r\n<td>每秒次数</td>\r\n</tr>\r\n<tr>\r\n<tr>\r\n<td><a href=\"https://github.com/httl/httl/blob/master/src/test/java/httl/test/performance/JavaCase.java\">java</a></td>\r\n<td><a href=\"https://github.com/httl/httl/blob/master/src/test/java/httl/test/performance/Books.java\">books.java</a></td>\r\n<td>0ms</td>\r\n<td>1ms</td>\r\n<td>0ms/28,778byte</td>\r\n<td>8,739ms/100,000</td>\r\n<td>11,442/s</td>\r\n</tr>\r\n<tr>\r\n<td><a href=\"https://github.com/httl/httl/blob/master/src/test/java/httl/test/performance/HttlCase.java\">httl</a></td>\r\n<td><a href=\"https://github.com/httl/httl/blob/master/src/test/resources/performance/books.httl\">books.httl</a></td>\r\n<td>88ms</td>\r\n<td>621ms</td>\r\n<td>3ms/28,778byte</td>\r\n<td>9,608ms/100,000</td>\r\n<td>10,407/s</td>\r\n</tr>\r\n<tr>\r\n<td><a href=\"https://github.com/httl/httl/blob/master/src/test/java/httl/test/performance/VelocityCase.java\">velocity</a></td>\r\n<td><a href=\"https://github.com/httl/httl/blob/master/src/test/resources/performance/books.vm\">books.vm</a></td>\r\n<td>21ms</td>\r\n<td>96ms</td>\r\n<td>23ms/28,172byte</td>\r\n<td>41,969ms/100,000</td>\r\n<td>2,382/s</td>\r\n</tr>\r\n<td><a href=\"https://github.com/httl/httl/blob/master/src/test/java/httl/test/performance/FreemarkerCase.java\">freemarker</a></td>\r\n<td><a href=\"https://github.com/httl/httl/blob/master/src/test/resources/performance/books.ftl\">books.ftl</a></td>\r\n<td>103ms</td>\r\n<td>121ms</td>\r\n<td>141ms/27,571byte</td>\r\n<td>56,192ms/100,000</td>\r\n<td>1,779/s</td>\r\n</tr>\r\n<tr>\r\n<td><a href=\"https://github.com/httl/httl/blob/master/src/test/java/httl/test/performance/Smarty4jCase.java\">smarty4j</a></td>\r\n<td><a href=\"https://github.com/httl/httl/blob/master/src/test/resources/performance/books.st\">books.st</a></td>\r\n<td>2ms</td>\r\n<td>75ms</td>\r\n<td>18ms/29,044byte</td>\r\n<td>65,855ms/100,000</td>\r\n<td>1,518/s</td>\r\n</tr>\r\n<tr>\r\n<td><a href=\"https://github.com/httl/httl/blob/master/src/test/java/httl/test/performance/BeetlCase.java\">beetl</a></td>\r\n<td><a href=\"https://github.com/httl/httl/blob/master/src/test/resources/performance/books.btl\">books.btl</a></td>\r\n<td>24ms</td>\r\n<td>11ms</td>\r\n<td>159ms/26,820byte</td>\r\n<td>81,428ms/100,000</td>\r\n<td>1,228/s</td>\r\n</tr>\r\n</table>\r\n\r\n环境：os: Mac OS X 10.8.2, cpu: 2 x 1.70GHz, mem: 4G, jvm: 1.7.0_09 -&gt; mem: 80M\r\n\r\n### HTTL的渲染速度接近于直接用Java硬编码输出，比其它模板引擎高出10倍。\r\n\r\nHTTL用到的JDK的Compiler，编译一个类通常需要几百毫秒，比其它模板的编译要慢，但每个模板只在加载时编译一次。\r\n\r\n注：不同环境的运行结果可能存在差异，以上测试数据仅供参考，你可以在自己的机器上执行测试：\r\n\r\n```bash\r\ngit clone https://github.com/httl/httl.git\r\ncd httl\r\nmvn test -Dtest=httl.test.PerformanceTest\r\n```\r\n\r\n## 2.2 优化策略\r\n\r\n### 2.2.1 强类型编译，并推导关联类型\r\n\r\n对于表达式${user.name}的编译：\r\n\r\n弱类型字节码生成：\r\n\r\n```java\r\nObject user = context.get(\"user\"); // 无法确定user是Map还是POJO\r\n// 反射获取属性的值，而且要运行期判断是user.getName()，还是user.name字段\r\nObject name = ReflectUtil.get(user, \"name\"); // 接下来name也要反射\r\n```\r\n\r\nHTTL强类型字节码生成：\r\n\r\n```java\r\nUser user = (User)context.get(\"user\"); // 通过in=\"User user\"声明类型\r\n// 编译期通过User的字段类型推演name的类型，并在编译期决定使用getName()\r\nString name = user.getName();\r\n```\r\n\r\n### 2.2.2 编译时就将文本编译成字节，加快输出\r\n\r\n文本编译：\r\n\r\n```java\r\nwriter.write(\"<table><tr><td>\");\r\nwriter.write(user.getName());\r\n```\r\n\r\n二进制编译：\r\n\r\n```java\r\noutput.write(new byte[] {60, 116, 97, 98, 108, 101, 62, 60, 116, 114, 62, 60, 116, 100, 62});\r\noutput.write(user.getName().getBytes());\r\n```\r\n\r\n这样可以大幅度降低IO输出时将文本通过字符集编码成二进制流的速度。\r\n\r\nHTTL缺省每模板同时生成两份class，在用户传入OutputStream和Writer时，执行不同的class：\r\n```java\r\ntemplate.render(paramaters, outputStream); // 内部将执行二进制输出版本的Template类\r\ntemplate.render(paramaters, writer); // 内部将执行文本输出版本的Template类\r\n```\r\n\r\n### 2.2.3 对于赋值生成局部变量，不put回参数map\r\n\r\n比如将：\r\n\r\n```xml\r\n<!--#set(price = price * discount / 100)-->\r\n${price}\r\n```\r\n\r\n编译成：\r\n\r\n```java\r\nint price = price * discount / 100;\r\nwrite(price);\r\n```\r\n\r\n而不是：\r\n\r\n```java\r\ncontext.put(\"price\", price * discount / 100);\r\nwrite(context.get(\"price\"));\r\n```\r\n\r\n这样可以大量减少参数map的put和get的调用。\r\n\r\n### 2.2.4 将文本不编译到字节码中，减少内存perm区占用，以及防止JIT失效：\r\n\r\n当模板的内容较大时，会导致生成的字节码也比较大，字节码运行时会放在内存perm区，导致perm区过大。\r\n模板多时，用户可能需要不断调大perm区：java -XX:PermSize=256MB -XX:MaxPermSize=256MB\r\n\r\n另外，SunJDK缺省对大于8K字节码的方法不进行JIT优化，我们常规开启的JVM是mixed模式的，\r\n即调用量大的，将由JIT编译成本地码运行，其它在JVM内解释执行，解释执行和编译执行的速度相差10倍以上。\r\n参见JVM的：[globals.hpp](http://hg.openjdk.java.net/jdk6/jdk6/hotspot/file/2ecd0d1194d2/src/share/vm/runtime/globals.hpp)\r\n```cpp\r\nproduct(bool, DontCompileHugeMethods, true,\r\n        \"don't compile methods > HugeMethodLimit\")\r\ndevelop(intx, HugeMethodLimit,  8000,\r\n        \"don't compile methods larger than this if +DontCompileHugeMethods\")\r\n```\r\n\r\n通过将文本不编译到字节码中，减少内存perm区占用，也能防止JIT失效。\r\n\r\n### 2.2.5 减少反射调用，以及基本类型装箱。\r\n\r\n因为模板输出的大量是基本类型和字符串，Httl遇到任何类似需要boxed和unboxed的地方，都会重载所有基本类型方法，以减少boxed和unboxed的处理。\r\n比如：当输出基本类型时，需要转成String，如果使用format(Object)接口，就会将基本类型装箱。\r\n\r\n反射也经常是性能瓶颈所在，比如：因为int[]不继承于Object[]，为了通用处理，改为Array.get(array, index)来获取数组的项，\r\n导致在Profiler分析时，发现80%的CPU时间都耗在Array.get()上。\r\n\r\n等等。\r\n\r\n## 2.3 语法对比 \r\n\r\n如果你用过Velocity模板，可以查看以下对比，加深了解：\r\n\r\n1. HTTL指令必需加注释外壳，只支持&lt;!--#if(x)--&gt;，不支持#if(x)，确保不干扰HTML本身的有效源码。 \r\n\r\n2. HTTL指令中的变量不加$符，只支持&lt;!--#foreach(book in books)--&gt;，不支持&lt;!--#foreach($book in $books)--&gt;，因为指令中没有加引号的字符串就是变量，和常规语言的语法一样，加$有点废话。 \r\n\r\n3. HTTL占位符必需加大括号，只支持${aaa}，不支持$aaa，因为$在JavaScript中也是合法变量名符号，而${}不是，减少混淆，也防止多人开发时，有人加大括号，有人不加，干脆没得选，都加，保持一致。 \r\n\r\n4. HTTL占位符当变量为null时输出空白串，而不像Velocity那样原样输出指令原文，即${aaa}，等价于Velocity的$!{aaa}，以免开发人员忘写感叹号，泄漏表达式源码，如需原样输出，可使用转义\\${aaa}，\r\n在HTTL中，$!{aaa}表示不对内容进行过滤，用于原样输出HTML片段。\r\n\r\n5. HTTL支持在所有使用变量的地方，进行表达式计算，也就是你不需要像Velocity那样，先#set($j = $i + 1)，再#if($j == $m)，可以直接&lt;!--#if(i + 1 == $m)--&gt;，其它指令也一样。\r\n\r\n6. HTTL采用扩展Class原生方法的方式，如：${\"a\".toChar}，而不像Velocity的Tool工具方法那样：$(StringTool.toChar(\"a\"))，这样的调用方式更直观，更符合代码书写习惯。\r\n\r\n## 2.4 指令对比\r\n\r\n<table>\r\n<tr><td>HTTL</td><td>Velocity</td><td>异同</td><td>功能</td></tr>\r\n<tr><td>${xxx.yyy}</td><td>$xxx.yyy<br/>${xxx.yyy}</td><td>相同</td><td>输出占位符</td></tr>\r\n<tr><td>$!{xxx.yyy}</td><td>$!xxx.yyy<br/>$!{xxx.yyy}</td><td>不同</td><td>一个是不过滤，一个是不原样输出</td></tr>\r\n<tr><td>&lt;!--## ... --&gt;</td><td>## ...<br/>#* ... *#</td><td>相似</td><td>不显示注释块</td></tr>\r\n<tr><td>&lt;![CDATA[## ... ]]&gt;</td><td>#[[ ... ]]#</td><td>相似</td><td>不解析文本块</td></tr>\r\n<tr><td>\\# \\$ \\\\</td><td>\\# \\$ \\\\</td><td>相同</td><td>特殊符转义</td></tr>\r\n<tr><td>&lt;!--#var(Xxx xxx)--&gt;</td><td>不支持</td><td>不同</td><td>定义输入参数类型</td></tr>\r\n<tr><td>&lt;!--#set(xxx = yyy)--&gt;</td><td>#set($xxx = $yyy)</td><td>相同</td><td>给变量赋值</td></tr>\r\n<tr><td>&lt;!--#if(xxx == yyy)--&gt;</td><td>#if($xxx == $yyy)</td><td>相同</td><td>条件判断</td></tr>\r\n<tr><td>&lt;!--#elseif(xxx == yyy)--&gt;</td><td>#elseif($xxx == $yyy)</td><td>相同</td><td>否则条件判断</td></tr>\r\n<tr><td>&lt;!--#else--&gt;</td><td>#else</td><td>相同</td><td>否则判断</td></tr>\r\n<tr><td>&lt;!--#end--&gt;</td><td>#end</td><td>相同</td><td>结束指令</td></tr>\r\n<tr><td>&lt;!--#foreach(item in list)--&gt;</td><td>#foreach($item in $list)</td><td>相同</td><td>列表循环</td></tr>\r\n<tr><td>&lt;!--#breakif(xxx == yyy)--&gt;</td><td>#if($xxx == $yyy) #break #end</td><td>相似</td><td>中断循环</td></tr>\r\n<tr><td>&lt;!--#macro(xxx)--&gt;</td><td>#macro($xxx)</td><td>相似</td><td>宏替换，模板片断</td></tr>\r\n<tr><td>&lt;!--#set(xxx=xxxmacro())--&gt;</td><td>#define($xxx)</td><td>相似</td><td>捕获块输出到变量中</td></tr>\r\n<tr><td>$!{read(\"xxx.txt\")}</td><td>#include(\"xxx.txt\")</td><td>相似</td><td>读取文本文件内容</td></tr>\r\n<tr><td>$!{include(\"xxx.httl\")}</td><td>#parse(\"xxx.vm\")</td><td>相似</td><td>包含另一模板输出</td></tr>\r\n<tr><td>$!{evaluate(\"1 + 2\")}</td><td>#evaluate(\"1 + 2\")</td><td>相似</td><td>表达式求值</td></tr>\r\n<tr><td>不支持</td><td>#stop</td><td>不同</td><td>停止模板解析</td></tr>\r\n</table>\r\n\r\n# 3. 示例\r\n\r\n## 3.1 调用示例\r\n\r\nBooksServlet.java:\r\n\r\n```java\r\nimport httl.*;\r\nimport java.util.*;\r\n\r\nMap<String, Object> parameters = new HashMap<String, Object>();\r\nparameters.put(\"user\", user);\r\nparameters.put(\"books\", books);\r\n\r\nEngine engine = Engine.getEngine();\r\nTemplate template = engine.getTemplate(\"books.httl\");\r\ntemplate.render(parameters, response.getWriter());\r\n```\r\n\r\n## 3.2 模板示例\r\n\r\nbooks.httl:\r\n\r\n```html\r\n<!--#var(User user, List<Book> books)-->\r\n<html>\r\n  <body>\r\n    <!--#if(user.role == \"admin\")-->\r\n    <table>\r\n      <!--#foreach(book in books)-->\r\n      <tr>\r\n        <td>${book.title}</td>\r\n      </tr>\r\n      <!--#end-->\r\n    </table>\r\n    <!--#end-->\r\n  </body>\r\n</html>\r\n```\r\n\r\n## 3.3 配置示例\r\n\r\nhttl.properties:\r\n\r\n```properties\r\nimport.packages+=com.xxx\r\ntemplate.directory=\r\ninput.encoding=UTF-8\r\noutput.encoding=UTF-8\r\n```\r\n\r\n其中，+=表示追加配置，而不覆盖缺省配置。\r\n注意，所有配置项都有缺省值，如果使用缺省值，可以不配，\r\n更多配置参见文档第7章。\r\n\r\n# 4. 设计\r\n\r\n## 4.1 类关系\r\n\r\n![类图](../diagram/httl-class-diagram.png)\r\n[大图](../diagram/httl-class-diagram.png)\r\n\r\n分包原则：按复用的粒度分包，如果某些类总是一起被复用，则放在一个包下面。 \r\n\r\nHTTL有两种用户： \r\n\r\n1. 一种是模板引擎的使用者， \r\n\r\n2. 一种是模板引擎的扩展者。 \r\n\r\n每种用户所需用到的类，就是同一复用粒度的。 \r\n\r\n所以在整体上划分为三层： \r\n\r\n1. API (Application Programming Interface) 直接使用者需要导入的接口。\r\n \r\n2. SPI (Service Provider Interface)  扩展者需要导入的接口。 \r\n\r\n3. Impl (Built-in Implementation) 内置扩展实现。 \r\n\r\n使用者API导入： \r\n\r\n```java\r\nimport httl.*;  \r\n```\r\n\r\n扩展者SPI导入： \r\n\r\n```java\r\nimport httl.spi.*;\r\n```\r\n\r\n## 4.2 调用过程\r\n\r\n![时序图](../diagram/httl-sequence-diagram.png)\r\n[大图](../diagram/httl-class-diagram.png)\r\n\r\n执行过程说明：(与上图中的序号对应) \r\n\r\n1. 当从引擎中获取模板时， \r\n\r\n2. 首先会在缓存查找是否已缓存，如果有缓存就直接返回， \r\n\r\n3. 如果没有，则加载模板， \r\n\r\n4. 接着进行模板语法解析， \r\n\r\n5. 在解析到表达式时，将其转译为Java表达式， \r\n\r\n6. 并对静态文本进行编译前过滤，比如删除空白等， \r\n\r\n7. 对解析后的Java代码进行编译，得到Template的具体模板实现类， \r\n\r\n8. 实例化模板实现类， \r\n\r\n9. 将模板实例写入缓存，并返回给用户， \r\n\r\n10. 当用户调用模板的渲染方法时， \r\n\r\n11. 将静态模板文本直接输出， \r\n\r\n12. 将动态占位符内容，先格式化成字符串， \r\n\r\n13. 再进行过滤，比如转义动态内容的HTML特殊符，\r\n \r\n14. 然后输出过滤后的内容。 \r\n\r\n# 5. 模板\r\n\r\n基于Velocity指令和Html注释:\r\n\r\n## 5.1 输出指令\r\n\r\n### 5.1.1 过滤输出\r\n\r\n输出表达式的计算结果，并进行过滤，比如：过滤变量中的HTML标签，防止HTML注入攻击。\r\n\r\n```xml\r\n格式：\r\n${expression}\r\n\r\n示例：\r\n${user.name}\r\n```\r\n\r\n### 5.1.2 不过滤输出\r\n\r\n原样输出表达式的计算结果，不进行任何过滤，通常用于输出HTML片段。\r\n\r\n```xml\r\n格式：\r\n$!{expression}\r\n\r\n示例：\r\n$!{body}\r\n```\r\n\r\n### 5.2 变量定义指令\r\n\r\n### 5.2.1 类型声明\r\n\r\n声明输入变量的类型，模板内部其它变量类型基于此类型推导。\r\n\r\n```xml\r\n格式：\r\n<!--#var(type name, type name)-->\r\n\r\n示例：\r\n<!--#var(User user, Book[] books)-->\r\n```\r\n\r\n### 5.2.2 变量赋值\r\n\r\n将表达式的计算结果存入变量中。\r\n\r\n```xml\r\n格式：\r\n<!--#set(type name = expression)-->\r\n\r\n示例：\r\n<!--#set(price = book.price * book.discount)-->\r\n```\r\n\r\n缺省模板中set的变量，是不会回写到Context的参数Map中的。\r\n你需要用“:=”进行赋值，才会回写到Context的参数Map中：\r\n\r\n```xml\r\n格式：\r\n<!--#set(type name := expression)-->\r\n\r\n示例：\r\n<!--#set(price := book.price * book.discount)-->\r\n```\r\n\r\n你可以通过ThreadLocal的Context.getContext().getParameters()拿到回写的变量：\r\n\r\n```java\r\n// 你可以把入参设成不可修写的Map，不会影响运行。\r\nMap<String, Object> parameters = Collections.unmodifiableMap(parameters);\r\n\r\n// 传入的parameters在渲染过程中总是不会被修复，确保渲染过程无副作用，以及多次渲染的幂等性。\r\ntemplate.render(parameters, writer);\r\n\r\n// 注意：这里获取到的并不是上面render参入的parameters，而是parameters的包装类。\r\n// 此parameters是可写的，当模板中set回写变量时，写入该Map中。\r\n// 在查询变量时，先在包装类中查找，找不到，再到原生传入的parameters中查找。\r\nContext.getContext().getParameters().get(\"price\");\r\n```\r\n\r\n## 5.3 条件指令\r\n\r\n### 5.3.1 IF条件\r\n\r\n如果条件表达式计算结果为真或非空，则输出指令所包含的块。\r\n\r\n```xml\r\n格式：\r\n<!--#if(expression)-->\r\n\r\n示例：\r\n<!--#if(user.role == \"admin\")-->\r\n    ...\r\n<!--#end-->\r\n```\r\n\r\n### 5.3.2 ELSEIF条件\r\n\r\n如果前面的IF条件不为真，并且当前条件表达式计算结果为真或非空，则输出指令所包含的块。\r\n\r\n```xml\r\n格式：\r\n<!--#elseif(expression)-->\r\n\r\n示例：\r\n<!--#if(user.role == \"admin\")-->\r\n    ...\r\n<!--#elseif(user.role == \"member\")-->\r\n    ...\r\n<!--#end-->\r\n```\r\n\r\n### 5.3.3 ELSE条件\r\n\r\n如果前面的IF条件不为真，则输出指令所包含的块。\r\n\r\n```xml\r\n格式：\r\n<!--#else-->\r\n\r\n示例：\r\n<!--#if(user.role == \"admin\")-->\r\n    ...\r\n<!--#else-->\r\n    ...\r\n<!--#end-->\r\n```\r\n\r\n## 5.4 迭代指令\r\n\r\n### 5.4.1 集合迭代\r\n\r\n迭代表达式产生的集合，以集合中的每项值，重复输出指令所包含的块。\r\n\r\n```xml\r\n格式：\r\n<!--#foreach(name in expression)-->\r\n\r\n示例：\r\n<!--#foreach(book in books)-->\r\n    ...\r\n    ${foreach.index}\r\n    ${foreach.size}\r\n    ${foreach.first}\r\n    ${foreach.last}\r\n<!--#end-->\r\n```\r\n\r\n### 5.4.3 中断迭代\r\n\r\n当条件表达式为真或非空时，中断当前迭代过程。\r\n\r\n```xml\r\n格式：\r\n<!--#breakif(expression)-->\r\n\r\n示例：\r\n<!--#foreach(book in books)-->\r\n    ...\r\n    <!--#breakif(foreach.index == 10)-->\r\n    ...\r\n<!--#end-->\r\n```\r\n\r\n## 5.5 宏指令\r\n\r\n将指令块封装成可复用的模板片断，在声明处不执行，在调用时再执行。\r\n\r\n```xml\r\n格式：\r\n<!--#macro(name(type name, type name))-->\r\n\r\n示例：\r\n<!--#macro(xxx(Book[] books))-->\r\n    ...\r\n<!--#end-->\r\n$!{xxx(books)}\r\n```\r\n\r\n## 5.6 字面指令\r\n\r\n### 5.6.1 注释块\r\n\r\n隐藏注释的内容，用于注解过程，或屏蔽指令内容。\r\n\r\n```xml\r\n格式：\r\n<!--## content -->\r\n\r\n示例：\r\n<!--## This is menu -->\r\n```\r\n\r\n### 5.6.2 不解析块\r\n\r\n原样输出模板内容，用于输出纯文本内容。\r\n\r\n```xml\r\n格式：\r\n<![CDATA[## content ]]>\r\n\r\n示例：\r\n<![CDATA[## This is menu ]]>\r\n```\r\n\r\n### 5.6.3 特殊符转义\r\n\r\n原样输出指令特殊符，用于输出纯文本内容。\r\n\r\n```xml\r\n格式：\r\n\\#, \\$, \\\\\r\n\r\n示例：\r\n<!--\\#xxx -->\r\n\\${xxx}\r\n```\r\n\r\n# 6. 表达式\r\n\r\n基于Java表达式和扩展方法。\r\n\r\n支持Java所有表达式，以下只列出与Java不同的点：\r\n\r\n* 所有null值的操作均返回null。\r\n* 所有实现Comparable的对象都支持比较运算符。\r\n* 所有对象都支持逻辑与或，分别返回空值或非空值。\r\n\r\n## 6.1 操作符表达式\r\n\r\n### 6.1.1 集合操作符\r\n\r\n```java\r\nSequence: 1..3\r\nList: [123, \"abc\"]\r\nMap: [\"xxx\": 123, \"yyy\": \"abc\"]\r\n```\r\n\r\n### 6.1.2 日期操作符\r\n\r\n```java\r\ndate1 > date2\r\ndate1 >= date2\r\ndate1 < date2\r\ndate1 <= date2\r\n```\r\n\r\n### 6.1.3 逻辑操作符\r\n\r\n```xml\r\n<!--#if(object)-->\r\n等价于：\r\n<!--#if(object != null)-->\r\n\r\n<!--#if(string)-->\r\n等价于：\r\n<!--#if(string!= null && string.length() > 0)-->\r\n\r\n<!--#if(list)-->\r\n等价于：\r\n<!--#if(list != null && list1.size() > 0)-->\r\n\r\n<!--#foreach(item in list1 || list2)-->\r\n等价于：\r\n<!--#foreach(item in list1 != null && list1.size() > 0 ? list1 : list2)-->\r\n```\r\n\r\n## 6.2 函数表达式\r\n\r\n### 6.2.1 转型函数\r\n\r\n```java\r\nobj.to(\"com.foo.Bar\")\r\nnum.toDate\r\nstr.toDate\r\nstr.toDate(\"yyyy-MM-dd HH:mm:ss\")\r\nstr.toChar\r\nstr.toBoolean\r\nstr.toByte\r\nstr.toInt\r\nstr.toLong\r\nstr.toFloat\r\nstr.toDouble\r\nstr.toClass\r\n```\r\n\r\n### 6.2.2 转义函数\r\n\r\n```java\r\nstr.escapeHtml\r\nstr.escapeUrl\r\nstr.escapeString\r\n```\r\n\r\n### 6.2.3 格式化函数\r\n\r\n```java\r\nnum.format(\"###,##0\")\r\nnum.format(\"###,##0.##\")\r\ndate.format(\"yyyy-MM-dd\")\r\ndate.format(\"yyyy-MM-dd HH:mm:ss\")\r\n```\r\n\r\n### 6.2.4 集合函数\r\n\r\n```xml\r\narray[index]\r\nlist[index]\r\n\r\nmap.key\r\nmap[\"key\"]\r\n\r\n<!--#foreach(item in array)-->\r\n${item.xxx}\r\n<!--#end-->\r\n\r\n<!--#foreach(item in list)-->\r\n${item.xxx}\r\n<!--#end-->\r\n\r\n<!--#foreach(entry in map)-->\r\n${entry.key}\r\n${entry.value}\r\n<!--#end-->\r\n\r\nsort(list)\r\n<!--#foreach(item in sort(list))-->\r\n<!--#end-->\r\n\r\ncycle(item, item)\r\n<!--#set(colors = cycle(\"red\", \"blue\", \"green\"))-->\r\n${colors.next}\r\n```\r\n\r\n### 6.2.5 文件函数\r\n\r\n```java\r\ninclude(\"template.httl\")}\r\ninclude(\"template.httl\", \"UTF-8\")\r\ninclude(locale(\"i18n-template.httl\"))\r\n\r\nread(\"text.txt\")\r\nread(\"text.txt\", \"UTF-8\")\r\nread(locale(\"i18n-text.txt\"))\r\n```\r\n\r\n### 6.2.6 系统函数\r\n\r\n```java\r\nnow()\r\nrandom()\r\nuuid()\r\n```\r\n\r\n# 7. 配置\r\n\r\n配置中，+=表示在缺省配置上追加配置，=表示覆盖缺省配置。\r\n\r\n## 7.1 模板引擎配置\r\n\r\n```properties\r\nengine=httl.spi.engines.DefaultEngine\r\nparser=httl.spi.parsers.CommentParser\r\ntranslator=httl.spi.translators.DfaTranslator\r\n```\r\n其中，engine负责组装，parser负责解析语法，translator负责将模板表达式翻译成java表达式。\r\n除非你想改变语法，或优化解析性能，否则此三项不需要配置。\r\n\r\n如果你喜欢HTML标签属性语法，可以配置：\r\n\r\n```properties\r\nparser=httl.spi.parsers.AttributeParser\r\n```\r\n\r\n语法如：\r\n\r\n```html\r\n<html var=\"User user, Book[] books\">\r\n  <body>\r\n    <table if=\"user.role == 'admin'\">\r\n      <tr foreach=\"book in books\">\r\n        <td>${book.title}</td>\r\n      </tr>\r\n    </table>\r\n  </body>\r\n</html>\r\n```\r\n\r\n如果属性和其它框架冲突，可以添加名字空间：\r\n\r\n```properties\r\nattribute.namespace=httl\r\n```\r\n\r\n属性语法需要用到jericho包解析HTML标签：\r\n\r\n[jericho-html-3.1.jar](http://central.maven.org/maven2/net/htmlparser/jericho/jericho-html/3.1/jericho-html-3.1.jar)\r\n\r\n```xml\r\n<dependency>\r\n\t<groupId>net.htmlparser.jericho</groupId>\r\n\t<artifactId>jericho-html</artifactId>\r\n\t<version>3.1</version>\r\n</dependency>\r\n```\r\n\r\n名称空间写法如：\r\n\r\n```html\r\n<tr httl:foreach=\"book in books\" />\r\n```\r\n\r\n你可以设置foreach状态的变量名，缺省为foreach：(缺省值不用配)\r\n\r\n```properties\r\nforeach.status=foreach\r\n```\r\n\r\n## 7.2 模板缓存配置\r\n\r\n缺省为强缓存，即所有模板加载后全部缓存：(缺省值不用配)\r\n\r\n```properties\r\ncache=httl.spi.caches.StrongCache\r\n```\r\n\r\n如果你的模板非常之多，内存不足以缓存所有模板，可以配置为LRU缓存：\r\n\r\n```properties\r\ncache=httl.spi.caches.LruCache\r\ncache.capacity=10000\r\n```\r\n\r\n如果不需要缓存，请设为：\r\n\r\n```properties\r\ncache=null\r\n```\r\n\r\n## 7.4 模板加载配置\r\n\r\n(1) 可以配置启动时预编译所有模板，会调用loader.list()扫描模板文件。\r\n\r\ntemplate.suffix用于loader.list()过滤模板文件。\r\n\r\n预编译缺省关闭：(缺省值不用配)\r\n\r\n```properties\r\nprecompiled=false\r\ntemplate.suffix=.httl\r\n```\r\n\r\n(2) 可以配置是否允许热加载，缺省为false：(缺省值不用配)\r\n\r\n```properties\r\nreloadable=false\r\n```\r\n\r\n开启热加载后，模板引擎在getTemplate()时会检查文件的lastModified时间，如果比上次加载的时间新，就重新加载。\r\n\r\n请注意：旧的模板不会被卸载，经常改文件会导致内存perm区越来越大，只能在开发阶段使用。\r\n\r\n(3) 可以配置模板加载缺省编码，缺省为UTF-8：(缺省值不用配)\r\n\r\n```properties\r\ninput.encoding=UTF-8\r\n```\r\n\r\n### 7.4.1 从Classpath下加载\r\n\r\n缺省从Classpath下加载，即模板放在任意jar包中：(缺省值不用配)\r\n\r\n```properties\r\nloaders=httl.spi.loaders.ClasspathLoader\r\ntemplate.directory=\r\n```\r\n\r\n### 7.4.2 从文件加载：\r\n\r\n```properties\r\nloaders=httl.spi.loaders.FileLoader\r\ntemplate.directory=/home/admin/templates\r\n```\r\n\r\n### 7.4.3 从jar包中加载：\r\n\r\n```properties\r\nloaders=httl.spi.loaders.JarLoader\r\ntemplate.directory=/home/admin/tempaltes.jar\r\n```\r\n\r\n### 7.4.4 从zip包中加载：\r\n\r\n```properties\r\nloaders=httl.spi.loaders.ZipLoader\r\ntemplate.directory=/home/admin/tempaltes.zip\r\n```\r\n\r\n### 7.4.5 从指定url加载：\r\n\r\n```properties\r\nloaders=httl.spi.loaders.UrlLoader\r\ntemplate.directory=http://myhost/tempaltes\r\n```\r\n\r\n### 7.4.6 从war包加载：\r\n\r\n```properties\r\nloaders=httl.spi.loaders.ServletLoader\r\ntemplate.directory=/WEB-INF/templates\r\n```\r\n\r\n需在web.xml中配置ServletLoader的listener：\r\n\r\n```xml\r\n<listener>\r\n    <listener-class>httl.spi.loaders.ServletLoader</listener-class>\r\n</listener>\r\n```\r\n\r\n### 7.4.7 从内存字符串加载：\r\n\r\n```properties\r\nloaders=httl.spi.loaders.StringLoader\r\n```\r\n\r\n然后编码加入模板内容：\r\n\r\n```java\r\nStringLoader.addResource(\"foo.httl\", \"<!--#var(User user)-->${user.name}\");\r\n```\r\n\r\n### 7.4.8 从多个源加载：\r\n\r\n```properties\r\nloaders=httl.spi.loaders.ClasspathLoader,httl.spi.loaders.FileLoader\r\n```\r\n\r\n或者使用\"+=\"保留缺省的classpath加载的同时，增加新的加载器：\r\n\r\n```properties\r\nloaders+=httl.spi.loaders.FileLoader\r\n```\r\n\r\n## 7.5 模板编译器\r\n\r\n用于将模板类编译成字节码，缺省使用jdk自带的编译器：(缺省值不用配)\r\n\r\n```properties\r\ncompiler=httl.spi.compilers.JdkCompiler\r\n```\r\n\r\n你也可以换成javassist编译：\r\n\r\n```properties\r\ncompiler=httl.spi.compilers.JavassistCompiler\r\n```\r\n\r\n当然，也就需要增加javassist的jar包依赖：\r\n\r\n[javassist-3.15.0-GA.jar](http://central.maven.org/maven2/org/javassist/javassist/3.15.0-GA/javassist-3.15.0-GA.jar)\r\n\r\n```xml\r\n<dependency>\r\n\t<groupId>org.javassist</groupId>\r\n\t<artifactId>javassist</artifactId>\r\n\t<version>3.15.0-GA</version>\r\n</dependency>\r\n```\r\n\r\n(1) 输出选项：\r\n\r\n如果设置output.stream=true，在编译期就会将模板文件转换成byte[]数据，\r\n在输出时，直接向OutputStream中输出byte[]流，以免运行期每次输出都要转一次。\r\n\r\n缺省全部开启：(缺省值不用配)\r\n\r\n```properties\r\noutput.stream=true\r\noutput.writer=true\r\n```\r\n\r\n如果output.stream和output.writer同时开启，每份模板将编译成两份class，并返回自适应Template代理类。\r\n当用户调用template.render(Map,OutputStream)时，实际执行输出byte[]的Template类，\r\n当用户调用template.render(Map,Writer)时，实际执行输出String的Template类。\r\n\r\n如果output.stream和output.writer同时关闭，只生成writer模板，相当于只开启output.writer。\r\n\r\n注意：\r\n如果只开启output.stream=true，必须用template.render(Map,OutputStream)，否则数据转换会导致性能更低。\r\n如果只开启output.writer=true，必须用template.render(Map,Writer)，否则数据转换会导致性能更低。\r\n\r\n如果你从来不传入OutputStream或Writer，请关闭相应配置开关，减少编译开销。\r\n\r\n(2) 内存选项：\r\n\r\n缺省将模板源码和模板文本都不编译到字节码中：(缺省值不用配)\r\n\r\n```properties\r\nsource.in.class=false\r\ntext.in.class=false\r\n```\r\n\r\n它通过一个Map缓存做中介，把模板源码和模板文本都放到了runtime属性中，以节省内存perm区大小。\r\n\r\n编译到字节码中，在读取时可以会稍快，但不建议改变此选项。\r\n\r\n(3) 版本选项：\r\n\r\njava版本的配置会影响字节码生成的版本。\r\n\r\n```properties\r\njava.version=1.6\r\n```\r\n\r\n(4) 调试选项：\r\n\r\n如果你想知道编译后的字节码是什么样的，可以开启debug模式，并设置编译目录，编译器会向指定目录输出.class文件。\r\n\r\n调试缺省关闭：(缺省值不用配)\r\n\r\n```properties\r\ndebug=false\r\ncompile.directory=\r\n```\r\n\r\n## 7.6 输出格式化器\r\n\r\n缺省加载了日期格式化器：(缺省值不用配)\r\n\r\n```properties\r\nformatters=httl.spi.formatters.DateFormatter\r\ndate.format=yyyy-MM-dd HH:mm:ss\r\ntime.zone=\r\n```\r\n\r\n你也可以设置时区，设置后，格式化的结果会带上时区的值：(缺省为当前系统时区)\r\n\r\n```properties\r\ntime.zone=+8\r\n```\r\n\r\n你可以使用\"+=\"保留缺省的日期格式化器的同时，增加新的格式化器：\r\n\r\n```properties\r\nformatters+=httl.spi.formatters.NumberFormatter\r\nnumber.format=###,##0.###\r\n```\r\n\r\n你还可以设置null,true,false值的输出，\r\n\r\nnull值缺省会输出空白，true,false原样输出：(缺省值不用配)\r\n\r\n```properties\r\nnull.value=\r\ntrue.value=true\r\nfalse.value=false\r\n```\r\n\r\n比如可以配为：\r\n\r\n```properties\r\nnull.value=N/A\r\ntrue.value=yes\r\nfalse.value=no\r\n```\r\n\r\n## 7.7 输出过滤器\r\n\r\n过滤器分为两类，一类是针对模板文本的，一类是针对动态插值的。\r\n\r\n模板文本过滤会在编译的时候执行，编译时即把模板文本替换掉，不影响输出时的性能。\r\n\r\n动态插值的过滤会在输出的时候执行，需小心过滤引起性能问题。\r\n\r\n缺省加载了动态插值HTML过滤，防止HTML注入攻击：(缺省值不用配)\r\n```properties\r\nvalue.filters=httl.spi.filters.EscapeHtmlFilter\r\ntext.filters=\r\n```\r\n\r\n比如你可以设置在编译时压缩模板文本的空白符：\r\n```properties\r\n# 将连续的空白符压缩成单个空格\r\ntext.filters=httl.spi.filters.CompressBlankFilter\r\n\r\n# 去掉所有空白符\r\ntext.filters=httl.spi.filters.ClearBlankFilter\r\n```\r\n\r\n你可以用filters同时设置value.filters和text.filters：\r\n\r\n```properties\r\nfilters=httl.spi.filters.CompressBlankFilter\r\n```\r\n\r\n等价于：\r\n\r\n```properties\r\nvalue.filters+=httl.spi.filters.CompressBlankFilter\r\ntext.filters+=httl.spi.filters.CompressBlankFilter\r\n```\r\n\r\n## 7.8 类型导入\r\n\r\n### 7.8.1 导入包名\r\n\r\n```properties\r\nimport.packages=java.util\r\n```\r\n\r\n这样你就可以在模板内用短类名，而不用带上全包名。\r\n\r\n### 7.8.2 导入方法\r\n\r\n缺省导入DefaultMethod类中的方法：(缺省值不用配)\r\n\r\n```properties\r\nimport.methods=httl.spi.methods.DefaultMethod\r\n```\r\n\r\n你可以使用\"+=\"保留缺省方法的同时，导入新的方法：\r\n\r\n```properties\r\nimport.methods+=com.foo.MyMethod\r\n```\r\n\r\n比如DefaultMethod有静态方法：(也可以是非静态方法)\r\n\r\n```java\r\npublic static String format(Date self, String format) {\r\n    return ...;\r\n}\r\npublic static char toChar(String self) {\r\n    return ...;\r\n}\r\npublic static Date now() {\r\n    return ...;\r\n}\r\n```\r\n\r\n则可以在模板中调用：\r\n\r\n```xml\r\n${date.format(\"yyyy-MM-dd\")}\r\n${str.toChar()}\r\n${now()}\r\n```\r\n\r\n原理：静态方法的第一个参数传入被操作者本身的引用，后面的参数调用时传入。\r\n\r\n如果你需要setEngine()注入引擎实例，或setXxx(String)注入配置项，可以导入非静态方法，但静态方法编译后更快。\r\n\r\n比如：\r\n\r\n```java\r\n// 将注入引擎本身\r\nprivate Engine engine;\r\npublic setEngine(Engine engine) {\r\n    this.engine = engine;\r\n}\r\n\r\n// 将注入httl.properties中input.encoding=UTF-8配置的值\r\nprivate String inputEncoding;\r\npublic setInputEncoding(String inputEncoding) {\r\n    this.inputEncoding = inputEncoding;\r\n}\r\n\r\n// 非静态方法导入\r\npublic String include(String templateName) {\r\n    return engine.getTemplate(templateName, inputEncoding).toString();\r\n}\r\n```\r\n\r\n使用方式一样：\r\n\r\n```xml\r\n${include(\"foo.httl\")}\r\n```\r\n\r\n### 7.8.3 导入宏\r\n\r\n```properties\r\nimport.macros=\r\n```\r\n\r\n### 7.8.4 导入序列\r\n\r\n用法如：\r\n\r\n```xml\r\n<!--#foreach(weekday in \"Monday\" .. \"Sunday\")-->\r\n${weekday}\r\n<!--#end-->\r\n```\r\n\r\n缺省包含星期和月份序列：(缺省值不用配)\r\n\r\n```properties\r\nsequences=Mon Tue Wed Thu Fri Sat Sun Mon,\\\r\nMonday Tuesday Wednesday Thursday Friday Saturday Sunday Monday,\\\r\nJan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec Jan,\\\r\nJanuary February March May June July August September October November December January\r\n```\r\n\r\n你可以使用\"+=\"保留缺省序列的同时，增加新的序列：\r\n\r\n```properties\r\nsequences+=金 木 水 火 土 金\r\n```\r\n\r\n## 7.9 日志输出配置\r\n\r\n缺省使用log4j输出日志：(缺省值不用配)\r\n\r\n```properties\r\nloggers=httl.spi.loggers.Log4jLogger\r\n```\r\n\r\n如果你需要使用其它日志工具输出日志，可配置自己的适配器。\r\n\r\n比如使用JDK的日志输出：\r\n\r\n```properties\r\nloggers=httl.spi.loggers.JdkLogger\r\n```\r\n\r\n你也可以同时输出到多个日志工具：\r\n\r\n```properties\r\nloggers=httl.spi.loggers.Log4jLogger,httl.spi.loggers.JdkLogger\r\n```\r\n\r\n或者使用\"+=\"保留缺省的log4j输出的同时，增加新的输出：\r\n\r\n```properties\r\nloggers+=httl.spi.loggers.JdkLogger\r\n```\r\n\r\n# 8. 集成\r\n\r\nWeb配置查找顺序：\r\n\r\n1.首先查找/WEB-INF/web.xml中的context-param，如：\r\n\r\n```xml\r\n<context-param>\r\n    <param-name>httl.properties</param-name>\r\n    <param-value>/WEB-INF/httl.properties</param-value>\r\n</context-param>\r\n```\r\n\r\n(注：如果配置路径以 / 开头则表示在web应用目录下，否则在ClassPath下查找)\r\n\r\n2.如果未配置，则查找默认WEB-INF路径：/WEB-INF/httl.properties\r\n\r\n3.如果WEB-INF中没有，则查找ClassPath根目录：httl.properties\r\n\r\n4.如果ClassPath根目录也没有，则使用标准配置。\r\n\r\n其中，httl.properties配置如：\r\n\r\n```properties\r\nloaders=httl.spi.loaders.ServletLoader\r\ntemplate.directory=/WEB-INF/templates\r\ninput.encoding=UTF-8\r\noutput.encoding=UTF-8\r\n```\r\n\r\n以上配置，对下面的所有MVC集成都有效。\r\n\r\n## 8.1 Spring MVC 集成\r\n\r\n配置springmvc-servlet.xml:\r\n\r\n```xml\r\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\r\n<!DOCTYPE beans PUBLIC \"-//SPRING//DTD BEAN 2.0//EN\" \r\n    \"http://www.springframework.org/dtd/spring-beans-2.0.dtd\">\r\n<beans>\r\n    <bean id=\"viewResolver\" class=\"httl.web.springmvc.HttlViewResolver\">\r\n        <property name=\"suffix\" value=\".httl\"/>\r\n        <property name=\"contentType\" value=\"text/html; charset=UTF-8\" />\r\n    </bean>\r\n</beans>\r\n```\r\n\r\n## 8.2 Struts 集成\r\n\r\n配置struts-default.xml:\r\n\r\n```xml\r\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>  \r\n<!DOCTYPE struts PUBLIC  \r\n    \"-//Apache Software Foundation//DTD Struts Configuration 2.0//EN\"  \r\n    \"http://struts.apache.org/dtds/struts-2.0.dtd\">\r\n<struts>\r\n    <package name=\"struts-default\" abstract=\"true\">\r\n    \t<result-types>\r\n    \t\t<result-type name=\"velocity\" class=\"httl.web.struts2.HttlResult\"/>\r\n    \t</result-types>\r\n    </package>\r\n<struts>\r\n```\r\n\r\n## 8.3 Filter 集成\r\n\r\n配置/WEB-INF/web.xml:\r\n\r\n```xml\r\n<servlet>\r\n    <servlet-name>yourservlet</servlet-name>\r\n    <servlet-class>com.foo.YourServlet</servlet-class>\r\n    <load-on-startup>1</load-on-startup>\r\n</servlet>\r\n<servlet-mapping>\r\n    <servlet-name>yourservlet</servlet-name>\r\n    <url-pattern>*.do</url-pattern>\r\n</servlet-mapping>\r\n\r\n<filter>\r\n    <filter-name>httl</filter-name>\r\n    <filter-class>httl.web.servlet.HttlFilter</filter-class>\r\n</filter>\r\n<filter-mapping>\r\n    <filter-name>httl</filter-name>\r\n    <url-pattern>*.do</url-pattern>\r\n</filter-mapping>\r\n```\r\n\r\n你需要在你的业务Servlet中，处理完业务后，将业务参数都写到request.setAttribute()中。\r\nHttlFilter会模板目录下读取请求path加.httl后缀的模板，然后以request中的变量进行渲染。\r\n\r\n## 8.4 Servlet 集成\r\n\r\n配置/WEB-INF/web.xml:\r\n\r\n```xml\r\n<servlet>\r\n    <servlet-name>yourservlet</servlet-name>\r\n    <servlet-class>com.foo.YourServlet</servlet-class>\r\n    <load-on-startup>1</load-on-startup>\r\n</servlet>\r\n<servlet-mapping>\r\n    <servlet-name>yourservlet</servlet-name>\r\n    <url-pattern>*.do</url-pattern>\r\n</servlet-mapping>\r\n\r\n<servlet>\r\n    <servlet-name>httl</servlet-name>\r\n    <servlet-class>httl.web.servlet.HttlServlet</servlet-class>\r\n    <load-on-startup>2</load-on-startup>\r\n</servlet>\r\n<servlet-mapping>\r\n    <servlet-name>httl</servlet-name>\r\n    <url-pattern>*.httl</url-pattern>\r\n</servlet-mapping>\r\n```\r\n\r\n你需要在你的业务Servlet中，处理完业务后，将业务参数都写到request.setAttribute()中，\r\n并将请求forward到指定模板，比如：request.getRequestDispatcher(\"foo.httl\").forward(request, response);\r\nHttlServlet会模板目录下读取forward过来的path同名的模板，然后以request中的变量进行渲染。\r\n\r\n# 9. 下载\r\n\r\n## 9.1 发布包:\r\n\r\n<https://github.com/httl/httl/downloads>\r\n\r\n## 9.2 源代码:\r\n\r\n<https://github.com/httl/httl>\r\n\r\n下载源码：\r\n\r\n```bash\r\ngit clone https://github.com/httl/httl.git\r\n```\r\n\r\n编译源码：\r\n\r\n```bash\r\nmvn install -Dmaven.test.skip\r\n```\r\n\r\n性能测试：\r\n\r\n```bash\r\nmvn test -Dtest=httl.test.PerformanceTest\r\n```\r\n\r\n生成Eclipse工程描述文件:\r\n\r\n```bash\r\nmvn eclipse:eclipse -DdownloadSources\r\n```\r\n\r\n导入Eclipse工程：\r\n\r\nEclipse -> File -> Import -> Existing Projects into Workspace -> Browse -> Finished\r\n\r\n将.httl文件以html编辑器格式打开：\r\n\r\nEclipse -> Window -> Preferences -> General -> Content Types -> Text -> HTML -> Add -> .httl\r\n\r\n## 9.3 Maven依赖:\r\n\r\n```xml\r\n<project>\r\n    <dependencies>\r\n        <dependency>\r\n            <groupId>httl</groupId>\r\n            <artifactId>httl</artifactId>\r\n            <version>1.0.0</version>\r\n            </dependency>\r\n    </dependencies>\r\n    <repositories>\r\n        <repository>\r\n            <id>httl-repository</id>\r\n            <name>Httl Repository</name>\r\n            <url>http://httl.github.com/maven/</url>\r\n        </repository>\r\n    </repositories>\r\n<project>\r\n```\r\n\r\n## 9.4 运行环境\r\n\r\n[JDK1.5+](http://www.oracle.com/technetwork/java/javase/downloads/index.html)\r\n\r\n缺省配置下，HTTL不需要依赖任何三方类库即可运行。\r\n\r\n## 9.5 开源许可\r\n\r\n[Apache License 2.0](http://www.apache.org/licenses/LICENSE-2.0)\r\n\r\n```\r\n版权所有 2011-2012 HTTL开发团队\r\n \r\n根据2.0版本Apache许可证(以下简称\"许可证\")授权；\r\n根据本许可证，用户可以不使用此文件。\r\n用户可从下列网址获得许可证副本：\r\n \r\n     http://www.apache.org/licenses/LICENSE-2.0\r\n \r\n除非因适用法律要求或书面同意，\r\n根据本许可证分发的软件是基于\"按原样\"基础提供的，\r\n无任何明示的或暗示的保证或条件。\r\n详见根据本许可证许可下特定语言的管辖权限和限制。\r\n```\r\n\r\n# 10. 变更\r\n\r\n## 10.1 HTTL 0.1.0 (2011-09-13)\r\n\r\n```\r\n第一个版本，基本功能实现，HTML属性语法解析。\r\n```\r\n\r\n## 10.2 HTTL 0.2.0 (2011-09-22)\r\n\r\n```\r\n1. 增加注释语法并设为缺省，如：<!--#if(...)--> \r\n2. 支持热加载，当文件变更时，自动重新加载，配置：reloadable=true \r\n3. 支持启动时预编译，配置：precompiled=true \r\n4. 异常信息显示出错位置周边内容，更容易排错 \r\n5. 支持注释块，不解释块，特殊符转义，如：\\#, \\$ \r\n6. 支持include,read,evaluate函数(可自行扩展)，如：${include(\"xxx.httl\")] \r\n7. 支持集合泛型参数，如：#define(List<Book> books) \r\n8. 自动空指针检测，比如：${user.role}，当user为null时不会空指针 \r\n9. 自动条件补全，比如：#if(books)等价于#if(books != null && books.size > 0) \r\n10. 支持foreach状态栈，多层foreach时，可通过${foreach.parent.index}获取上层foreach状态 \r\n11. 允许设置foreach状态变量名 \r\n12. 支持方括号数组，如：#foreach(c in [a, b, c]) \r\n13. 支持双点号序列，如：#foreach(c in a..c)或#foreach(i in 1..2)或#foreach(day in \"Monday\"..\"Sunday\") \r\n14. 支持集合或运算，选择不为空的集合，如：#foreach(book in books1 | books2) \r\n15. 支持Date类型比较，如：#if(date1 > date2) \r\n16. 支持new操作，如：${new Date()} \r\n17. 支持强制转型，如：#set(user = (User) param) \r\n18. 增加HttlServlet，支持将请求经过MVC框架处理并填充request属性后forward到HttlServlet进行页面渲染 \r\n19. 兼容JDK1.5，需配置：compiler=com.googlecode.httl.support.compilers.JavassistCompiler \r\n```\r\n\r\n## 10.3 HTTL 1.0.0 (2012-10-30)\r\n\r\n```\r\n修复问题：\r\n1. 解决foreach和if/else联合使用时状态错乱问题。\r\n2. 解决getIsXxx属性解析出错问题。\r\n3. 解决文件加载未使用指定编码问题。\r\n4. 解决部分文件流打开后未关闭问题。\r\n5. 解决迭代map出错的问题，以及Map数据的类型推断问题。\r\n\r\n新功能：\r\n6. 支持单独的macro文件定义宏方法，通过import.macros配置加载。\r\n7. 增加gt,ge,lt,le符号，在属性语法时避免表达式出现HTML标签符。\r\n\r\n兼容优化：\r\n8. 静态方法不走engine.getFunction()查找实例，直接调用类的静态方法。\r\n9. 将所有配置的获取改为setter注入，比如：setInputEncoding(String)。\r\n10. 编译Macro时直接注入到模板属性中，并增加template.getMacros()方法。\r\n11. 渲染过程不改变传入Map的状态，保证模板渲染的无副作用性，以及多次渲染的幂等性。\r\n12. 优化Profiler性能分析发现的ArrayIterator引起的性能损耗问题。\r\n13. 将文本内容不编译到字节码中，改为从缓存中获取，防止内存Perm区过大，并提供source.in.class和text.in.class开关项。\r\n\r\n不兼容优化：\r\n14. 将define指令名改成var，以免和velocity的define指令理解混淆，影响所有旧模板，用户可全文替换。\r\n15. 去掉block指令，用#set(xxx = xxxmacro())代替，影响使用block的模板。\r\n16. 将com.googlecode.httl改成httl，影响API调用，重新Ctrl+Shift+O导入一下包名即可，类名没变。\r\n17. 将com.googlecode.httl.support改成httl.spi，影响httl.properties中扩展点的配置，使用缺省配置值的，建议不要配到用户配置中。\r\n18. 将filters配置项改成了value.filters，与text.filters对应用，影响httl.properties中filter扩展点的配置。\r\n19. 将functions配置项成了import.methods，与import.packages以及import.macros对应，方便理解。\r\n20. 加号数字优先，即只要有一方为数字即换数字计算，如：\"2\" + 3，输出：5，而不是：23，如果要字符相拼双方都要为字符：\"2\" + 3.toString\r\n```\r\n","name":"<HTTL/>","tagline":"HTTL是一个适用于HTML输出的开源JAVA模板引擎.","google":""}