{"tagline":"HTTL是一个高性能的JAVA开源模板引擎.","note":"Don't delete this file! It's used internally to help with page regeneration.","google":"","name":"<HTTL/>","body":"# 1.概述\r\n\r\nHTTL（Hyper-Text Template Language）是一个高性能的JAVA开源模板引擎，适用于动态HTML页面输出，可替代JSP页面，它的指令和Velocity相似。 \r\n\r\n### 快速\r\n将模板编译成JAVA字节码运行，并使用强类型推导，减少运行期反射和转型，渲染速度比Velocity,Freemarker等模板引擎快近10倍，请参见第3章的性能对比。注：JSP只有Scriptlet是编译的，Tag和EL是解释执行的，而HTTL是全编译的。\r\n\r\n### 简洁\r\n保持最简洁指令集，只保留基本的占位/注释/转义，和必需的变量/条件/循环/宏等控制指令，其它都降级为表达式方法实现，比如指令：#include(\"a.httl\")，改为普通函数：${include(\"a.httl\")}。\r\n\r\n### 直觉\r\n语法尽可能符合HTML和JAVA开发者的直觉，指令类似于常用Velocity指令，但改进了Velocity中不符合直觉的地方，比如输出时不能直接运算：${i + 1}，需要先#set给一个临时变量，具体请参见第5章与Velocity的对比。\r\n\r\n### 友好\r\n模板自描述，在模板内声明入参变量类型，并基于入参类型推导模板内所有变量类型，使IDE能方便的实现变量方法补全提示，对开发过程友好。\r\n\r\n# 2.示例\r\n\r\n## 2.1 调用示例\r\n\r\nBooksServlet.java:\r\n\r\n```java\r\nimport httl.*;\r\nimport java.util.*;\r\n\r\nMap<String, Object> parameters = new HashMap<String, Object>();\r\nparameters.put(\"user\", user);\r\nparameters.put(\"books\", books);\r\n\r\nEngine engine = Engine.getEngine();\r\nTemplate template = engine.getTemplate(\"/books.httl\");\r\ntemplate.render(parameters, response.getOutputStream());\r\n```\r\n\r\n注：缺省配置下，HTTL不依赖任何三方库，只需JDK1.5+即可。\r\n\r\n## 2.2 模板示例\r\n\r\nbooks.httl:\r\n\r\n```html\r\n<!--#var(User user, Book[] books)-->\r\n<html>\r\n  <body>\r\n    <!--#if(user.role == \"admin\")-->\r\n    <table>\r\n      <!--#foreach(book in books)-->\r\n      <tr>\r\n        <td>${book.title}</td>\r\n      </tr>\r\n      <!--#end-->\r\n    </table>\r\n    <!--#end-->\r\n  </body>\r\n</html>\r\n```\r\n\r\n或者：(需配置parser=httl.spi.parsers.AttributeParser)\r\n\r\n```html\r\n<html var=\"User user, Book[] books\">\r\n  <body>\r\n    <table if=\"user.role == 'admin'\">\r\n      <tr foreach=\"book in books\">\r\n        <td>${book.title}</td>\r\n      </tr>\r\n    </table>\r\n  </body>\r\n</html>\r\n```\r\n\r\n## 2.3 配置示例\r\n\r\nhttl.properties:\r\n\r\n```properties\r\nimport.packages+=com.xxx\r\ntemplate.directory=/META-INF/templates\r\ninput.encoding=UTF-8\r\noutput.encoding=UTF-8\r\n```\r\n\r\n其中，+=表示追加配置，而不覆盖缺省配置。\r\n注意，所有配置项都有缺省值，如果使用缺省值，可以不配，\r\n更多配置参见文档第8章。\r\n\r\n# 3.性能\r\n\r\n## 3.1 性能对比\r\n\r\n性能测试类：[PerformanceTest.java](https://github.com/httl/httl/blob/master/src/test/java/httl/test/PerformanceTest.java)\r\n\r\n<table>\r\n<tr>\r\n<td>引擎</td>\r\n<td>模板</td>\r\n<td>初始化</td>\r\n<td>编译</td>\r\n<td>首渲染</td>\r\n<td>输出大小</td>\r\n<td>十万渲染</td>\r\n<td>每秒次数</td>\r\n</tr>\r\n<tr></tr>\r\n<tr>\r\n<td><a href=\"https://github.com/httl/httl/blob/master/src/test/java/httl/test/performance/JavaCase.java\">java</a></td>\r\n<td><a href=\"https://github.com/httl/httl/blob/master/src/test/java/httl/test/performance/Books.java\">books.java</a></td>\r\n<td>0ms</td>\r\n<td>1ms</td>\r\n<td>0ms</td>\r\n<td>28,778byte</td>\r\n<td>8,739ms</td>\r\n<td>11,442/s</td>\r\n</tr>\r\n<tr>\r\n<td><a href=\"https://github.com/httl/httl/blob/master/src/test/java/httl/test/performance/HttlCase.java\">httl</a></td>\r\n<td><a href=\"https://github.com/httl/httl/blob/master/src/test/resources/performance/books.httl\">books.httl</a></td>\r\n<td>88ms</td>\r\n<td>621ms</td>\r\n<td>3ms</td>\r\n<td>28,778byte</td>\r\n<td>9,608ms</td>\r\n<td>10,407/s</td>\r\n</tr>\r\n<tr>\r\n<td><a href=\"https://github.com/httl/httl/blob/master/src/test/java/httl/test/performance/VelocityCase.java\">velocity</a></td>\r\n<td><a href=\"https://github.com/httl/httl/blob/master/src/test/resources/performance/books.vm\">books.vm</a></td>\r\n<td>21ms</td>\r\n<td>96ms</td>\r\n<td>23ms</td>\r\n<td>28,172byte</td>\r\n<td>41,969ms</td>\r\n<td>2,382/s</td>\r\n</tr>\r\n<td><a href=\"https://github.com/httl/httl/blob/master/src/test/java/httl/test/performance/FreemarkerCase.java\">freemarker</a></td>\r\n<td><a href=\"https://github.com/httl/httl/blob/master/src/test/resources/performance/books.ftl\">books.ftl</a></td>\r\n<td>103ms</td>\r\n<td>121ms</td>\r\n<td>141ms</td>\r\n<td>27,571byte</td>\r\n<td>56,192ms</td>\r\n<td>1,779/s</td>\r\n<tr>\r\n<td><a href=\"https://github.com/httl/httl/blob/master/src/test/java/httl/test/performance/Smarty4jCase.java\">smarty4j</a></td>\r\n<td><a href=\"https://github.com/httl/httl/blob/master/src/test/resources/performance/books.st\">books.st</a></td>\r\n<td>2ms</td>\r\n<td>75ms</td>\r\n<td>18ms</td>\r\n<td>29,044byte</td>\r\n<td>65,855ms</td>\r\n<td>1,518/s</td>\r\n</tr>\r\n</table>\r\n\r\n环境：os: Mac OS X 10.8.2, cpu: 2 x 1.70GHz, mem: 4G, jvm: 1.7.0_09 -&gt; mem: 80M\r\n\r\n### HTTL的渲染速度接近于直接用Java硬编码输出，比其它模板引擎高近10倍。\r\n\r\nHTTL用到的JDK的Compiler，编译一个类通常需要几百毫秒，比其它模板的编译要慢，但每个模板只在加载时编译一次。\r\n\r\n以上测试，不包含HTTL在编译期将静态文本转成byte[]，以减少输出时重复转码的优化。\r\n全部采用忽略输出的方式进行测试，测的是模板引擎纯渲染时间，否则HTTL将更快。\r\n如果要测试该优化项，不能忽略输出时的编码开销，否则将不公平。\r\n\r\n另外，HTTL缺省开启了EscapeXmlFilter，而其它模板引擎没有，为了公平，性能测试时配置关闭了Filter:\r\n\r\n```properties\r\nvalue.filter=null\r\n```\r\n\r\n注：不同环境的运行结果可能存在差异，以上测试数据仅供参考，你可以在自己的机器上执行测试：\r\n\r\n```bash\r\ngit clone https://github.com/httl/httl.git\r\ncd httl\r\nmvn test -Dtest=httl.test.PerformanceTest -Dcount=10000\r\n```\r\n\r\n## 3.2 优化策略\r\n\r\n### 3.2.1 强类型编译，并推导关联类型\r\n\r\n对于表达式${user.name}的编译：\r\n\r\n弱类型字节码生成：\r\n\r\n```java\r\nObject user = context.get(\"user\"); // 无法确定user是Map还是POJO\r\n// 反射获取属性的值，而且要运行期判断是user.getName()，还是user.name字段\r\nObject name = ReflectUtil.get(user, \"name\"); // 接下来name也要反射\r\n```\r\n\r\nHTTL强类型字节码生成：\r\n\r\n```java\r\nUser user = (User)context.get(\"user\"); // 通过<!--#var(User user)-->声明类型\r\n// 在编译期决定使用getName()方法获取属性的值，并通过getUser()的返回类型推演name的类型\r\nString name = user.getName();\r\n```\r\n\r\n### 3.2.2 编译时就将文本编译成字节，加快输出\r\n\r\n文本编译：\r\n\r\n```java\r\nwriter.write(\"<table><tr><td>\");\r\nwriter.write(user.getName());\r\n```\r\n\r\n二进制编译：\r\n\r\n```java\r\nprivate static final byte[] _B1_ = new byte[] {60, 116, 97, 98, 108, 101, 62, 60, 116, 114, 62, 60, 116, 100, 62};\r\noutput.write(_B1_);\r\noutput.write(user.getName().getBytes());\r\n```\r\n\r\n这样可以大幅度降低IO输出时将文本通过字符集编码成二进制流的速度，否则一个页面被渲染一亿次，上面的静态文本就要被编码一亿次。\r\n\r\nHTTL缺省每模板同时生成两份class，在用户传入OutputStream和Writer时，执行不同的class：\r\n```java\r\ntemplate.render(paramaters, outputStream); // 内部将执行二进制输出版本的Template类\r\ntemplate.render(paramaters, writer); // 内部将执行文本输出版本的Template类\r\n```\r\n\r\n### 3.2.3 对于赋值生成局部变量，不put回参数map\r\n\r\n比如将：\r\n\r\n```xml\r\n<!--#set(price = price * discount / 100)-->\r\n${price}\r\n```\r\n\r\n编译成：\r\n\r\n```java\r\nint price = price * discount / 100;\r\nwrite(price);\r\n```\r\n\r\n而不是：\r\n\r\n```java\r\ncontext.put(\"price\", price * discount / 100);\r\nwrite(context.get(\"price\"));\r\n```\r\n\r\n这样可以大量减少参数map的put和get的调用，减少hash查找的时间。\r\n\r\n### 3.2.4 将文本不编译到字节码中，减少内存perm区占用，以及防止JIT失效：\r\n\r\n当模板的内容较大时，会导致生成的字节码也比较大，字节码运行时会放在内存perm区，导致perm区过大。\r\n模板多时，用户可能需要不断调大perm区：java -XX:PermSize=256MB -XX:MaxPermSize=256MB\r\n\r\n另外，SunJDK缺省对大于8K字节码的方法不进行JIT优化，我们常规开启的JVM是mixed模式的，\r\n即调用量大的，将由JIT编译成本地码运行，其它在JVM内解释执行，解释执行和编译执行的速度相差10倍以上。\r\n参见JVM的：[globals.hpp](http://hg.openjdk.java.net/jdk6/jdk6/hotspot/file/2ecd0d1194d2/src/share/vm/runtime/globals.hpp)\r\n```cpp\r\nproduct(bool, DontCompileHugeMethods, true,\r\n        \"don't compile methods > HugeMethodLimit\")\r\ndevelop(intx, HugeMethodLimit,  8000,\r\n        \"don't compile methods larger than this if +DontCompileHugeMethods\")\r\n```\r\n\r\n通过将文本不编译到字节码中，减少内存perm区占用，也能防止JIT失效。\r\n\r\n将：\r\n\r\n```java\r\n// 如果这个串有8K以上，就会导致生成的字节码超过8K\r\nwriter.write(\"...A Large String...\");\r\n```\r\n\r\n改成：\r\n\r\n```java\r\n// 在生成字节码前，将文本内容存到一个Map缓存中，\r\n// 在生成的类加载时，类的静态字段从缓存中读取值，并删除缓存，\r\n// 这样文本内容，就从字节码存储的Perm区，转到了常量对象存储的Old区，\r\n// 因为是静态字段，所以不会影响模板执行性能。\r\nprivate static final String _TXT1_ = StringCache.getAndRemove(\"1\");\r\nwriter.write(_TXT1_);\r\n```\r\n\r\n### 3.2.5 减少反射调用，无用锁，以及基本类型装箱。\r\n\r\n反射经常是性能瓶颈所在，HTTL对所有反射调用的地方都很非常小心，\r\n比如：因为int[]不继承于Object[]，为了通用处理，改为Array.get(array, index)来获取数组的项，\r\n导致在Profiler分析时，发现80%的CPU时间都耗在Array.get()上。\r\n\r\n因为模板输出的大量是基本类型和字符串，Httl遇到任何类似需要boxed和unboxed的地方，\r\n都会重载所有基本类型方法，以减少boxed和unboxed的处理。\r\n比如：当输出基本类型时，需要转成String，如果使用format(Object)接口，就会将基本类型装箱。\r\n\r\nJDK6加入的Biased Locking优化是有开销和不稳定性的，\r\n所以程序中无用的锁是可能影响性能的，HTTL会主动规避JDK中的无用锁，\r\n比如：覆盖方法去掉Writer,ByteArrayOutputStream等的锁。\r\n\r\n等等。一切影响性能的细节，持续关注和优化中。\r\n\r\n# 4.设计\r\n\r\n## 4.1 类关系\r\n\r\n![类图](http://httl.github.com/images/httl-class-diagram.png)\r\n\r\n[查看大图](http://httl.github.com/images/httl-class-diagram.png)\r\n\r\n### 4.1.1 核心领域模型划分原则：按实体域，服务域，会话域划分。 \r\n\r\n不管你做一个什么产品，都一定有一个被操作的主体，比如：服务框架管理的Service，任务框架管理的Task，Spring管理的Bean等，这就是实体域。\r\n\r\n即然有被操作者，就一定有操作者，它管理被操作者的生命周期，发起动作，比如：服务框架的ServiceInvoker,，任务框架的TaskScheduler，Spring的BeanFactory等，这就是服务域。\r\n\r\n服务域发起动作，在执行过程中，会有一些临时状态需要存储交换，比如：Invacation，Execution，Request等，这就是会话域。\r\n\r\n![领域模型划分](http://httl.github.com/images/core-domain.png)\r\n\r\n相应的，在HTTL中：\r\n\r\n* Engine 为服务域\r\n  * 它是API的入口，并负责实体域Template的生命周期管理，它是Singleton单一实例的，加载后不可变，所以是线程安全的，它的初始化过程较重，请复用单例。\r\n* Template 为实体域\r\n  * 代表着被操作者，它是Prototype原型实例的，即每个模板产生一个实例，加载后不可变，同样也是线程安全的，模板变化后，将产生不同的实例，而不改变原实例。\r\n* Context 为会话域\r\n  * 持有操作过程中的所有可变状态，它是ThreadLocal线程内实例的，即不和其它线程竞争使用，所以也是线程安全的，请不要跨线程传递，它的初始化过程很轻量，每次模板执行前都新建实例，执行完即销毁。\r\n\r\n这样划分的好处是，职责清晰，可变状态集中，每个域都是无锁线程安全的，保证在大并发下，不会降低系统的活性。\r\n\r\n### 4.1.2 分包原则：按复用度，抽象度，稳定度分包。\r\n\r\n* 复用度：\r\n  * 每种用户所需用到的类，就是同一复用粒度的，比如：使用者和扩展者，这样可以减少代码干扰，以及最大化复用。\r\n* 稳定度：\r\n  * 被依赖包和依赖包的占比，如果一个包依赖很多包，那别的包变化都会引起它跟随变化，所以它就不稳定，反之即稳定，保持包的稳定度和抽象度成正比，即把抽象类(包括接口)放到稳定的包中，这样可以防止不稳定性传染。\r\n* 抽象度：\r\n  * 包中抽象类个数占比，比如包中有10个类，其中3个为抽象类(包括接口)，则抽象度为3/10，保持被依赖者总是比依赖者的抽象度高，形成金子塔关系，这样可以保持每层都有足够的扩展性。 \r\n\r\n稳定度与抽象度关系如下图：\r\n\r\n![稳定度与抽象度关系](http://httl.github.com/images/abstract-stable.png)\r\n\r\n也就是分包应该如下：\r\n\r\n![稳定度与抽象度包结构](http://httl.github.com/images/abstract-stable-package.png)\r\n\r\n其中上面那个包不依赖其它包。所以它很稳定，应尽量把抽象类或接口放在这一层，\r\n\r\n而下面那个包依赖了三个包，三个包变化都会引起它跟随变化，所以它是不稳定的，应尽量把具体实现类放在这一层。\r\n\r\n因稳定度与抽象度成正比，所以不稳定度与抽象度成反比，用反比方便画图，计算方式如下：\r\n\r\n* (1) I = Ce / (Ca + Ce)\r\n  * I: Instability (不稳定度)\r\n  * Ca: Afferent Coupling (传入依赖，也就是被其它包依赖的个数)\r\n  * Ce: Efferent Coupling (输出依赖，也就是依赖其它包的个数)\r\n* (2) A = Na / Nc\r\n  * A: Abstractness (抽象度)\r\n  * Na: Number of abstract classes (抽象类的个数)\r\n  * Nc: Number of classes (类的个数，包括抽象类)\r\n* (3) D = abs(1 - I - A) * sin(45)\r\n  * D: Distance (偏差)\r\n  * I: Instability (不稳定度)\r\n  * A: Abstractness (抽象度)\r\n \r\n应该保持偏差越小越好，即下图所示交点都落在绿色反比线左右：\r\n\r\n![不稳定度与抽象度比](http://httl.github.com/images/iad-metrics.gif)\r\n\r\n基于上面的原则，HTTL的包结构整体上划分为三层：\r\n\r\n* API (Application Programming Interface)\r\n  * 模板引擎的使用者依赖的接口类，也是核心领域模型所在，保持最少概念，并隐藏实现细节，其中Engine类相当于微内核，只管理非功能性的扩展点的加载，不硬编码模板加载解析渲染的任何部分。\r\n* SPI (Service Provider Interface)\r\n  * 模板引擎的扩展者依赖的接口类，它依赖于API的领域模型，它是模板引擎功能正交分解的抽象层，以保证用户可以最小粒度替换需要改写的地方，方便二次开发。\r\n* BUILT-IN (Built-in Implementation)\r\n  * 内置扩展实现，它是SPI标准实现，也是可被用户替换的类，它包含引擎所有做的事，包括扩展点之间的组装过程(可替换DefaultEngine)，以确保没有功能换不掉，即平等对待扩展者。\r\n\r\n采用子包依赖父包风格，所以将API放在根目录，SPI接口独立子包，各种实现放在SPI的下一级子包中。\r\n\r\n* 使用者API导入：import httl.*;  \r\n* 扩展者SPI导入：import httl.spi.*;\r\n\r\n下图是HTTL所有包的不稳定度与抽象度的比值距阵：(下图为JDepend绘制)\r\n\r\n![HTTL不稳定度与抽象度比](http://httl.github.com/images/httl-metrics.png)\r\n\r\nHTTL所有核心包都是靠近反比线的，即上图中用绿色标识的点，表示分包是合理的。\r\n\r\n注：图中黑色的点为util相关包，它们不抽象，却被很多包依赖，只是内部复用代码，不影响整体设计，用户请不要依赖HTTL的util类。\r\n\r\n## 4.2 调用过程\r\n\r\n![时序图](http://httl.github.com/images/httl-sequence-diagram.png)\r\n\r\n[查看大图](http://httl.github.com/images/httl-sequence-diagram.png)\r\n\r\n执行过程说明：(与上图中的序号对应) \r\n\r\n1 当从引擎中获取模板时，\r\n\r\n1.1 首先会在缓存查找是否已缓存，如果有缓存就直接返回， \r\n\r\n1.2 如果没有，则加载模板， \r\n\r\n1.3 接着进行模板语法解析， \r\n\r\n1.3.1 在解析到表达式时，将其转译为Java表达式， \r\n\r\n1.3.2 并对静态文本进行编译前过滤，比如删除空白等， \r\n\r\n1.3.3 对解析后的Java代码进行编译，得到具体模板实现类， \r\n\r\n1.3.4 实例化模板实现类， \r\n\r\n1.4 将模板实例写入缓存，并返回给用户， \r\n\r\n2 当用户调用模板的渲染方法时， \r\n\r\n2.1 如果是静态文本直接输出，\r\n\r\n2.2 如果是动态变量内容，先将其格式化成字符串， \r\n\r\n2.3 再进行过滤，比如转义动态内容的HTML特殊符，\r\n\r\n2.4 然后输出过滤后的内容。\r\n\r\n# 5.语法\r\n\r\n## 5.1 注释语法\r\n\r\n基于Velocity指令和Html注释:\r\n\r\n```html\r\n<!--#var(User user, Book[] books)-->\r\n<html>\r\n  <body>\r\n    <!--#if(user.role == \"admin\")-->\r\n    <table>\r\n      <!--#foreach(book in books)-->\r\n      <tr>\r\n        <td>${book.title}</td>\r\n      </tr>\r\n      <!--#end-->\r\n    </table>\r\n    <!--#end-->\r\n  </body>\r\n</html>\r\n```\r\n\r\n如果你用过Velocity模板，可以查看以下对比，加深了解：\r\n\r\n### 5.1.1 语法对比 \r\n\r\n1. HTTL指令必需加注释外壳，只支持&lt;!--#if(x)--&gt;，不支持#if(x)，确保不干扰HTML本身的有效源码。 \r\n\r\n2. HTTL指令中的变量不加$符，只支持&lt;!--#foreach(book in books)--&gt;，不支持&lt;!--#foreach($book in $books)--&gt;，因为指令中没有加引号的字符串就是变量，和常规语言的语法一样，加$有点废话，而且容易忘写。\r\n\r\n3. HTTL占位符必需加大括号，只支持${aaa}，不支持$aaa，因为$在JavaScript中也是合法变量名符号，而${}不是，减少混淆，也防止多人开发时，有人加大括号，有人不加，干脆没得选，都加，保持一致。 \r\n\r\n4. HTTL占位符当变量为null时输出空白串，而不像Velocity那样原样输出指令原文，即${aaa}，等价于Velocity的$!{aaa}，以免开发人员忘写感叹号，泄漏表达式源码，如需原样输出，可使用转义\\${aaa}，\r\n在HTTL中，$!{aaa}表示不对内容进行过滤，用于原样输出HTML片段。\r\n\r\n5. HTTL支持在所有使用变量的地方，进行表达式计算，也就是你不需要像Velocity那样，先#set($j = $i + 1)，再${j}，可以直接${i + 1}，其它指令也一样，比如：&lt;!--#if(i + 1 == n)--&gt;。\r\n\r\n6. HTTL采用扩展Class原生方法的方式，如：${\"a\".toChar}，而不像Velocity的Tool工具方法那样：$(StringTool.toChar(\"a\"))，这样的调用方式更直观，更符合代码书写习惯。\r\n\r\n### 5.1.2 指令对比\r\n\r\n<table>\r\n<tr><td>HTTL</td><td>Velocity</td><td>异同</td><td>功能</td></tr>\r\n<tr><td>${xxx.yyy}</td><td>$xxx.yyy<br/>${xxx.yyy}</td><td>相同</td><td>输出占位符</td></tr>\r\n<tr><td>$!{xxx.yyy}</td><td>$!xxx.yyy<br/>$!{xxx.yyy}</td><td>不同</td><td>一个是不过滤，一个是不原样输出</td></tr>\r\n<tr><td>&lt;!--## ... --&gt;</td><td>## ...<br/>#* ... *#</td><td>相似</td><td>不显示注释块</td></tr>\r\n<tr><td>&lt;![CDATA[## ... ]]&gt;</td><td>#[[ ... ]]#</td><td>相似</td><td>不解析文本块</td></tr>\r\n<tr><td>\\# \\$ \\\\</td><td>\\# \\$ \\\\</td><td>相同</td><td>特殊符转义</td></tr>\r\n<tr><td>&lt;!--#var(Xxx xxx)--&gt;</td><td>不支持</td><td>不同</td><td>定义输入参数类型</td></tr>\r\n<tr><td>&lt;!--#set(xxx = yyy)--&gt;</td><td>#set($xxx = $yyy)</td><td>相同</td><td>给变量赋值</td></tr>\r\n<tr><td>&lt;!--#if(xxx == yyy)--&gt;</td><td>#if($xxx == $yyy)</td><td>相同</td><td>条件判断</td></tr>\r\n<tr><td>&lt;!--#elseif(xxx == yyy)--&gt;</td><td>#elseif($xxx == $yyy)</td><td>相同</td><td>否则条件判断</td></tr>\r\n<tr><td>&lt;!--#else--&gt;</td><td>#else</td><td>相同</td><td>否则判断</td></tr>\r\n<tr><td>&lt;!--#end--&gt;</td><td>#end</td><td>相同</td><td>结束指令</td></tr>\r\n<tr><td>&lt;!--#foreach(item in list)--&gt;</td><td>#foreach($item in $list)</td><td>相同</td><td>列表循环</td></tr>\r\n<tr><td>&lt;!--#breakif(xxx == yyy)--&gt;</td><td>#if($xxx == $yyy) #break #end</td><td>相似</td><td>中断循环</td></tr>\r\n<tr><td>&lt;!--#macro(xxx)--&gt;</td><td>#macro($xxx)</td><td>相似</td><td>宏替换，模板片断</td></tr>\r\n<tr><td>&lt;!--#set(xxx=xxxmacro())--&gt;</td><td>#define($xxx)</td><td>相似</td><td>捕获块输出到变量中</td></tr>\r\n<tr><td>$!{read(\"xxx.txt\")}</td><td>#include(\"xxx.txt\")</td><td>相似</td><td>读取文本文件内容</td></tr>\r\n<tr><td>$!{include(\"xxx.httl\")}</td><td>#parse(\"xxx.vm\")</td><td>相似</td><td>包含另一模板输出</td></tr>\r\n<tr><td>$!{evaluate(\"1 + 2\")}</td><td>#evaluate(\"1 + 2\")</td><td>相似</td><td>表达式求值</td></tr>\r\n<tr><td>不支持</td><td>#stop</td><td>不同</td><td>停止模板解析</td></tr>\r\n</table>\r\n\r\n缺省使用HTML注释语法，如：\r\n\r\n```html\r\n<!--#var(User user, Book[] books)-->\r\n<html>\r\n  <body>\r\n    <!--#if(user.role == \"admin\")-->\r\n    <table>\r\n      <!--#foreach(book in books)-->\r\n      <tr>\r\n        <td>${book.title}</td>\r\n      </tr>\r\n      <!--#end-->\r\n    </table>\r\n    <!--#end-->\r\n  </body>\r\n</html>\r\n```\r\n\r\n## 5.2 属性语法\r\n\r\n基于Html标签属性: (指令和表达式与注释语法相同)\r\n\r\n```html\r\n<html var=\"User user, Book[] books\">\r\n  <body>\r\n    <table if=\"user.role == 'admin'\">\r\n      <tr foreach=\"book in books\">\r\n        <td>${book.title}</td>\r\n      </tr>\r\n    </table>\r\n  </body>\r\n</html>\r\n```\r\n\r\n需要配置：\r\n\r\n```properties\r\nparser=httl.spi.parsers.AttributeParser\r\n```\r\n\r\n属性语法需要用到jericho包解析HTML标签：\r\n\r\n[jericho-html-3.1.jar](http://central.maven.org/maven2/net/htmlparser/jericho/jericho-html/3.1/jericho-html-3.1.jar)\r\n\r\n```xml\r\n<dependency>\r\n\t<groupId>net.htmlparser.jericho</groupId>\r\n\t<artifactId>jericho-html</artifactId>\r\n\t<version>3.1</version>\r\n</dependency>\r\n```\r\n\r\n如果属性和其它框架冲突，可以添加名字空间：\r\n\r\n```properties\r\nattribute.namespace=httl\r\n```\r\n\r\n名称空间写法如：\r\n\r\n```html\r\n<tr httl:foreach=\"book in books\" />\r\n```\r\n\r\n# 6.指令\r\n\r\n## 6.1 输出指令\r\n\r\n### 6.1.1 过滤输出\r\n\r\n输出表达式的计算结果，并进行过滤，比如：过滤变量中的HTML标签。\r\n\r\n```xml\r\n格式：\r\n${expression}\r\n\r\n示例：\r\n${user.name}\r\n```\r\n\r\n注：HTTL缺省开启了EscapeXmlFilter，以防止HTML注入XSS攻击。如果你需要更强的过滤，请自行实现Filter，并配置到value.filters。此处为运行时热点，请注意性能。\r\n\r\n### 6.1.2 不过滤输出\r\n\r\n原样输出表达式的计算结果，不进行任何过滤，通常用于输出HTML片段。\r\n\r\n```xml\r\n格式：\r\n$!{expression}\r\n\r\n示例：\r\n$!{body}\r\n```\r\n\r\n### 6.2 变量定义指令\r\n\r\n### 6.2.1 类型声明\r\n\r\n声明输入变量的类型，模板内部其它变量类型基于此类型推导。\r\n\r\n```xml\r\n格式：\r\n<!--#var(type name, type name)-->\r\n\r\n示例：\r\n<!--#var(User user, Book[] books)-->\r\n```\r\n\r\n### 6.2.2 变量赋值\r\n\r\n将表达式的计算结果存入变量中。\r\n\r\n```xml\r\n格式：\r\n<!--#set(type name = expression)-->\r\n\r\n示例：\r\n<!--#set(price = book.price * book.discount)-->\r\n<!--#set(int price = book.price * book.discount)-->\r\n```\r\n\r\n类型的声明，同时可以用作强制转型，比如：\r\n\r\n```xml\r\n<!--#set(Book book = bookentry.value)-->\r\n```\r\n\r\n如果bookentry.value的类型丢失，上面的写法可以恢复book的类型。\r\n\r\n一个set指令可同时有多个赋值，用分号分隔，如：\r\n\r\n```xml\r\n<!--#set(price = book.price; discount = book.discount)-->\r\n```\r\n\r\n缺省模板中set的变量，是不会回写到Context的参数Map中的。\r\n你需要用“:=”进行赋值，才会回写到Context的参数Map中：\r\n\r\n```xml\r\n格式：\r\n<!--#set(type name := expression)-->\r\n\r\n示例：\r\n<!--#set(price := book.price * book.discount)-->\r\n```\r\n\r\n你可以通过ThreadLocal的Context.getContext().getParameters()拿到回写的变量：\r\n\r\n```java\r\n// 你可以把入参设成不可修改的Map，不会影响运行。\r\nMap<String, Object> parameters = Collections.unmodifiableMap(parameters);\r\n\r\n// 传入的parameters在渲染过程中总是不会被修改，确保渲染过程无副作用，以及多次渲染的幂等性。\r\ntemplate.render(parameters, writer);\r\n\r\n// 注意：这里获取到的并不是上面render传入的parameters，而是parameters的包装类。\r\n// 此包装类是可写的，并且写入不会影响原生传入的parameters，当模板中set回写变量时，写入该Map中。\r\n// 在查询变量时，先在包装类中查找，找不到，再到原生传入的parameters中查找。\r\nContext.getContext().getParameters().get(\"price\");\r\n```\r\n\r\n## 6.3 条件指令\r\n\r\n### 6.3.1 IF条件\r\n\r\n如果条件表达式计算结果为真或非空，则输出指令所包含的块。\r\n\r\n```xml\r\n格式：\r\n<!--#if(expression)-->\r\n\r\n示例：\r\n<!--#if(user.role == \"admin\")-->\r\n    ...\r\n<!--#end-->\r\n```\r\n\r\n### 6.3.2 ELSEIF条件\r\n\r\n如果前面的IF条件不为真，并且当前条件表达式计算结果为真或非空，则输出指令所包含的块。\r\n\r\n```xml\r\n格式：\r\n<!--#elseif(expression)-->\r\n\r\n示例：\r\n<!--#if(user.role == \"admin\")-->\r\n    ...\r\n<!--#elseif(user.role == \"member\")-->\r\n    ...\r\n<!--#end-->\r\n```\r\n\r\n### 6.3.3 ELSE条件\r\n\r\n如果前面的IF条件不为真，则输出指令所包含的块。\r\n\r\n```xml\r\n格式：\r\n<!--#else-->\r\n\r\n示例：\r\n<!--#if(user.role == \"admin\")-->\r\n    ...\r\n<!--#else-->\r\n    ...\r\n<!--#end-->\r\n```\r\n\r\n## 6.4 迭代指令\r\n\r\n### 6.4.1 集合迭代\r\n\r\n迭代表达式产生的集合，以集合中的每项值，重复输出指令所包含的块。\r\n\r\n```xml\r\n格式：\r\n<!--#foreach(type name in expression)-->\r\n\r\n示例：\r\n<!--#foreach(book in books)-->\r\n    ...\r\n    ${foreach.index}\r\n    ${foreach.size}\r\n    ${foreach.first}\r\n    ${foreach.last}\r\n<!--#end-->\r\n```\r\n\r\n类型的声明，同时可以用作强制转型，比如：\r\n\r\n```xml\r\n<!--#foreach(Book book in booklist)-->\r\n    ${book.title}\r\n<!--#end-->\r\n```\r\n\r\n如果booklist的泛型丢失，上面的写法可以恢复book的类型。\r\n\r\n### 6.4.3 中断迭代\r\n\r\n当条件表达式为真或非空时，中断当前迭代过程。\r\n\r\n```xml\r\n格式：\r\n<!--#breakif(expression)-->\r\n\r\n示例：\r\n<!--#foreach(book in books)-->\r\n    ...\r\n    <!--#breakif(foreach.index == 10)-->\r\n    ...\r\n<!--#end-->\r\n```\r\n\r\n## 6.5 宏指令\r\n\r\n将指令块封装成可复用的模板片断，在声明处不执行，在调用时再执行。\r\n\r\n```xml\r\n格式：\r\n<!--#macro(name(type name, type name))-->\r\n\r\n示例：\r\n<!--#macro(xxx(Book[] books))-->\r\n    ...\r\n<!--#end-->\r\n$!{xxx(books)}\r\n<!--#set(xxx := xxx(books))-->\r\n```\r\n\r\n## 6.6 字面指令\r\n\r\n### 6.6.1 注释块\r\n\r\n隐藏注释的内容，用于注解过程，或屏蔽指令内容。\r\n\r\n```xml\r\n格式：\r\n<!--## content -->\r\n\r\n示例：\r\n<!--## This is menu -->\r\n```\r\n\r\n### 6.6.2 不解析块\r\n\r\n原样输出模板内容，用于输出纯文本内容。\r\n\r\n```xml\r\n格式：\r\n<![CDATA[## content ]]>\r\n\r\n示例：\r\n<![CDATA[## This is menu ]]>\r\n```\r\n\r\n### 6.6.3 特殊符转义\r\n\r\n原样输出指令特殊符，用于输出纯文本内容。\r\n\r\n```xml\r\n格式：\r\n\\#, \\$, \\\\\r\n\r\n示例：\r\n<!--\\#xxx -->\r\n\\${xxx}\r\n\\\\${xxx}\r\n```\r\n\r\n# 7.表达式\r\n\r\n基于Java表达式和扩展方法。\r\n\r\n支持Java所有表达式，以下只列出与Java不同的点：\r\n\r\n* 所有null值的操作均返回null，比如：${foo.bar.blabla}，如果foo为null，后面所有的操作最终为null，而不会空指针。\r\n* 双等号\"==\"会被解析成equals()方法比较，而不是比内存地址。\r\n* 加号\"+\"数字优先，${1 + \"2\"}输出3，而不是12，字符串拼接尽量用${s1}${s2}，而不是${s1 + s2}\r\n* Bean属性会解析成getter方法调用，${user.name}等价于${user.getName()}\r\n* 所有实现Comparable的对象都支持比较运算符，比如：#if(date1 < date2)，可以比较日期的先后。\r\n* 所有对象都支持逻辑与或，分别返回空值或非空值，比如：${list1 || list2}，如果list1不为空则返回list1，否则返回list2。\r\n* List和Map可以方括号取值，比如：list[0]等价于list.get(0)，map[\"abc\"]等价于map.get(\"abc\")\r\n\r\n属性查找顺序，以${obj.foo}为例：\r\n\r\n* 首先查找有没有导入obj类型的foo()静态方法\r\n* 再查找obj.getFoo()函数\r\n* 再查找obj.isFoo()函数\r\n* 再查找obj.foo()函数\r\n* 再查找obj.foo属性\r\n\r\n## 7.1 操作符表达式\r\n\r\n### 7.1.1 集合操作符\r\n\r\n```xml\r\n${list[0]} 等价于：${list.get(0)}\r\n\r\n${map.abc} 等价于：${map.get(\"abc\")}\r\n\r\n${map[\"a.b.c\"]} 等价于：${map.get(\"a.b.c\")}\r\n\r\n序列生成: 1..3\r\n比如：\r\n<!--#foreach(i in 1..10)-->\r\n${i}\r\n<!--#end-->\r\n\r\nList生成: [123, \"abc\", var]\r\n比如：\r\n<!--#foreach(color in [\"red\", \"yellow\", \"blue\"])-->\r\n${color}\r\n<!--#end-->\r\n\r\nMap生成: [\"xxx\": 123, \"yyy\": \"abc\", \"zzz\": var]\r\n比如：\r\n<!--#foreach(entry in [\"red\": \"#FF0000\", \"yellow\": \"#00FF00\"])-->\r\n${entry.key} = ${entry.value}\r\n<!--#end-->\r\n\r\n集合相加：list1 + list2\r\n比如：\r\n<!--#foreach(item in list1 + list2)-->\r\n${item}\r\n<!--#end-->\r\n```\r\n\r\n### 7.1.2 逻辑操作符\r\n\r\n```xml\r\n<!--#if(object)-->\r\n等价于：\r\n<!--#if(object != null)-->\r\n\r\n<!--#if(string)-->\r\n等价于：\r\n<!--#if(string!= null && string.length() > 0)-->\r\n\r\n<!--#if(list)-->\r\n等价于：\r\n<!--#if(list != null && list1.size() > 0)-->\r\n\r\n<!--#foreach(item in list1 || list2)-->\r\n等价于：\r\n<!--#foreach(item in list1 != null && list1.size() > 0 ? list1 : list2)-->\r\n```\r\n\r\n### 7.1.3 日期操作符\r\n\r\n```java\r\ndate1 > date2\r\ndate1 >= date2\r\ndate1 < date2\r\ndate1 <= date2\r\n```\r\n\r\n## 7.2 函数表达式\r\n\r\n### 7.2.1 转型函数\r\n\r\n```java\r\nobj.to(\"com.foo.Bar\")\r\nnum.toDate\r\nstr.toDate\r\nstr.toDate(\"yyyy-MM-dd HH:mm:ss\")\r\nstr.toChar\r\nstr.toBoolean\r\nstr.toByte\r\nstr.toInt\r\nstr.toLong\r\nstr.toFloat\r\nstr.toDouble\r\nstr.toClass\r\n```\r\n\r\n### 7.2.2 转义函数\r\n\r\n```java\r\nstr.escapeXml\r\nstr.escapeUrl\r\nstr.escapeString\r\n```\r\n\r\n### 7.2.3 格式化函数\r\n\r\n```java\r\nnum.format(\"###,##0\")\r\nnum.format(\"###,##0.##\")\r\ndate.format(\"yyyy-MM-dd\")\r\ndate.format(\"yyyy-MM-dd HH:mm:ss\")\r\n```\r\n\r\n### 7.2.4 集合函数\r\n\r\n```xml\r\n# 数组和List一样可以用size方法获取大小\r\narray.size\r\nlist.size\r\nmap.size\r\n\r\n# List和数组一样可以用方括号下标获取值\r\narray[index]\r\nlist[index]\r\n\r\n# Map和Bean一样可以用属性获取键值\r\nbean.property\r\nbean[\"property\"]\r\nmap.key\r\nmap[\"key\"]\r\n\r\n<!--#foreach(item in array)-->\r\n${item.xxx}\r\n<!--#end-->\r\n\r\n<!--#foreach(item in list)-->\r\n${item.xxx}\r\n<!--#end-->\r\n\r\n<!--#foreach(entry in map)-->\r\n${entry.key}\r\n${entry.value}\r\n<!--#end-->\r\n\r\nsort(list)\r\n<!--#foreach(item in sort(list))-->\r\n<!--#end-->\r\n\r\ncycle(item, item)\r\n<!--#set(colors = cycle(\"red\", \"blue\", \"green\"))-->\r\n<!--#foreach(item in list)-->\r\n${colors.next}\r\n<!--#end-->\r\n```\r\n\r\n### 7.2.5 文件函数\r\n\r\n```java\r\ninclude(\"template.httl\")}\r\ninclude(\"template.httl\", \"UTF-8\")\r\ninclude(locale(\"i18n-template.httl\"))\r\n\r\nread(\"text.txt\")\r\nread(\"text.txt\", \"UTF-8\")\r\nread(locale(\"i18n-text.txt\"))\r\n```\r\n\r\n### 7.2.6 国际化函数\r\n\r\n```\r\n${\"key\".i18n} 或 ${i18n(\"key\")}\r\n依次查找下面文件中的key配置：\r\nbasename_zh_CN.properties\r\nbasename_zh.properties\r\nbasename.properties\r\n\r\n$!{include(\"template.httl\".locale)} 或 $!{include(locale(\"template.httl\"))}\r\n依次查找以下文件是否存在：\r\ntemplate_zh_CN.httl\r\ntemplate_zh.httl\r\ntemplate.httl\r\n```\r\n\r\nhttl.properties相关配置：\r\n\r\n```\r\n# 国际化信息配置文件前缀，将从Loader中查找/WEB-INF/messages_zh_CN.properties\r\ni18n.basename=/WEB-INF/messages\r\n\r\n# 国际化信息格式，支持message和string，分别对应MessagFormat.format()和String.format()\r\ni18n.format=message\r\n\r\n# 用户可以直接用UTF-8文件保存国际化信息，而不需要ascii2native\r\ni18n.encoding=UTF-8\r\n\r\n# 缺省区域信息\r\nlocale=zh_CN\r\n```\r\n\r\n### 7.2.7 系统函数\r\n\r\n```java\r\nnow()\r\nrandom()\r\nuuid()\r\n```\r\n\r\n# 8.配置\r\n\r\n配置中，+=表示在缺省配置上追加配置，=表示覆盖缺省配置，多个值用逗号分隔。\r\n\r\n## 8.1 模板引擎配置\r\n\r\n```properties\r\nengine=httl.spi.engines.DefaultEngine\r\nparser=httl.spi.parsers.CommentParser\r\ntranslator=httl.spi.translators.DfaTranslator\r\n```\r\n其中，engine负责组装，parser负责解析语法，translator负责将模板表达式翻译成java表达式。\r\n除非你想改变语法，或优化解析性能，否则此三项不需要配置。\r\n\r\n你可以设置foreach状态的变量名，缺省为foreach：(缺省值不用配)\r\n\r\n```properties\r\nforeach.status=foreach\r\n```\r\n\r\n## 8.2 模板缓存配置\r\n\r\n缺省为强缓存，即所有模板和表达式加载后全部缓存：(缺省值不用配)\r\n\r\n```properties\r\ntemplate.cache=httl.spi.caches.TemplateAdaptiveCache\r\nexpression.cache=httl.spi.caches.ExpressionAdaptiveCache\r\ntemplate.cache.capacity=\r\nexpression.cache.capacity=\r\n```\r\n\r\n当配置的capacity大于0，AdaptiveCache将适配到LRU(最近最少使用)实现，否则将适配到全缓存实现。\r\n\r\n如果你的模板非常之多，内存不足以缓存所有模板，可以配置缓存容量：（将自动启用LRU丢弃策略）\r\n\r\n```properties\r\ntemplate.cache.capacity=10000\r\nexpression.cache.capacity=10000\r\n```\r\n\r\n你也可以用cache.capacity同时设置模板和表达式两者的缓存：(和上面的配置等价)\r\n\r\n```properties\r\ncache.capacity=10000\r\n```\r\n\r\n开发阶段，可以开启热加载：\r\n\r\n```properties\r\nreloadable=true\r\n```\r\n\r\n## 8.4 模板加载配置\r\n\r\n(1) 可以配置启动时预编译所有模板，会调用loader.list()扫描模板文件。\r\n\r\ntemplate.suffix用于loader.list()过滤模板文件。\r\n\r\n预编译缺省关闭：(缺省值不用配)\r\n\r\n```properties\r\nprecompiled=false\r\ntemplate.suffix=.httl\r\n```\r\n\r\n(2) 可以配置是否允许热加载，缺省为false：(缺省值不用配)\r\n\r\n```properties\r\nreloadable=false\r\n```\r\n\r\n开启热加载后，模板引擎在getTemplate()时会检查文件的lastModified时间，如果比上次加载的时间新，就重新加载。\r\n\r\n请注意：旧的模板不会被卸载，经常改文件会导致内存perm区越来越大，只能在开发阶段使用。\r\n\r\n(3) 可以配置模板加载缺省编码，缺省为UTF-8：(缺省值不用配)\r\n\r\n```properties\r\ninput.encoding=UTF-8\r\n```\r\n\r\n### 8.4.1 从Classpath下加载\r\n\r\n缺省从Classpath下加载，即模板放在任意jar包中：(缺省值不用配)\r\n\r\n```properties\r\nloaders=httl.spi.loaders.ClasspathLoader\r\ntemplate.directory=\r\n```\r\n\r\n### 8.4.2 从文件加载：\r\n\r\n```properties\r\nloaders=httl.spi.loaders.FileLoader\r\ntemplate.directory=/home/admin/templates\r\n```\r\n\r\n### 8.4.3 从jar包中加载：\r\n\r\n```properties\r\nloaders=httl.spi.loaders.JarLoader\r\ntemplate.directory=/home/admin/tempaltes.jar\r\n```\r\n\r\n### 8.4.4 从zip包中加载：\r\n\r\n```properties\r\nloaders=httl.spi.loaders.ZipLoader\r\ntemplate.directory=/home/admin/tempaltes.zip\r\n```\r\n\r\n### 8.4.5 从指定url加载：\r\n\r\n```properties\r\nloaders=httl.spi.loaders.UrlLoader\r\ntemplate.directory=http://myhost/tempaltes\r\n```\r\n\r\n### 8.4.6 从war包加载：\r\n\r\n```properties\r\nloaders=httl.spi.loaders.ServletLoader\r\ntemplate.directory=/WEB-INF/templates\r\n```\r\n\r\n需在web.xml中配置ServletLoader的listener：\r\n\r\n```xml\r\n<listener>\r\n    <listener-class>httl.spi.loaders.ServletLoader</listener-class>\r\n</listener>\r\n```\r\n\r\n### 8.4.7 从内存字符串加载：\r\n\r\n```properties\r\nloaders=httl.spi.loaders.StringLoader\r\n```\r\n\r\n然后编码加入模板内容：\r\n\r\n```java\r\nStringLoader.addResource(\"foo.httl\", \"<!--#var(User user)-->${user.name}\");\r\n```\r\n\r\n### 8.4.8 从多个源加载：\r\n\r\n```properties\r\nloaders=httl.spi.loaders.ClasspathLoader,httl.spi.loaders.FileLoader\r\n```\r\n\r\n或者使用\"+=\"保留缺省的classpath加载的同时，增加新的加载器，多个值用逗号分隔：\r\n\r\n```properties\r\nloaders+=httl.spi.loaders.FileLoader\r\n```\r\n\r\n## 8.5 模板编译器\r\n\r\n用于将模板类编译成字节码，缺省使用根据JDK版本自适应编译器：(缺省值不用配)\r\n\r\n```properties\r\ncompiler=httl.spi.compilers.AdaptiveCompiler\r\n```\r\n\r\n当前运行环境为JDK1.6以前版本时，AdaptiveCompiler将适配到JavassistCompiler，否则将适配到JdkCompiler。\r\n\r\n你可以强制指定使用jdk自带的编译器：\r\n\r\n```properties\r\ncompiler=httl.spi.compilers.JdkCompiler\r\n```\r\n\r\n你也可以换成javassist编译：\r\n\r\n```properties\r\ncompiler=httl.spi.compilers.JavassistCompiler\r\n```\r\n\r\n当然，也就需要增加javassist的jar包依赖：\r\n\r\n[javassist-3.15.0-GA.jar](http://central.maven.org/maven2/org/javassist/javassist/3.15.0-GA/javassist-3.15.0-GA.jar)\r\n\r\n```xml\r\n<dependency>\r\n\t<groupId>org.javassist</groupId>\r\n\t<artifactId>javassist</artifactId>\r\n\t<version>3.15.0-GA</version>\r\n</dependency>\r\n```\r\n\r\n(1) 输出选项：\r\n\r\n如果设置output.stream=true，在编译期就会将模板文件转换成byte[]数据，\r\n在输出时，直接向OutputStream中输出byte[]流，以免运行期每次输出都要转一次。\r\n\r\n缺省全部开启：(缺省值不用配)\r\n\r\n```properties\r\noutput.stream=true\r\noutput.writer=true\r\n```\r\n\r\n如果output.stream和output.writer同时开启，每份模板将编译成两份class，并返回自适应Template代理类。\r\n当用户调用template.render(Map,OutputStream)时，实际执行输出byte[]的Template类，\r\n当用户调用template.render(Map,Writer)时，实际执行输出String的Template类。\r\n\r\n如果output.stream和output.writer同时关闭，只生成writer模板，相当于只开启output.writer。\r\n\r\n注意：\r\n如果只开启output.stream=true，必须用template.render(Map,OutputStream)，否则数据转换会导致性能更低。\r\n如果只开启output.writer=true，必须用template.render(Map,Writer)，否则数据转换会导致性能更低。\r\n\r\n如果你从来不传入OutputStream或Writer，请关闭相应配置开关，减少编译开销。\r\n\r\n(2) 内存选项：\r\n\r\n缺省将模板源码和模板文本都不编译到字节码中：(缺省值不用配)\r\n\r\n```properties\r\nsource.in.class=false\r\ntext.in.class=false\r\n```\r\n\r\n它通过一个Map缓存做中介，把模板源码和模板文本都放到了runtime属性中，以节省内存perm区大小。\r\n\r\n编译到字节码中，在小模板时，可能会稍快，但不会有质的飞跃，在模板大于8K时，会导致JVM的JIT优化失效，会更慢，不建议改变此选项。\r\n\r\n(3) 版本选项：\r\n\r\njava版本的配置会影响字节码生成的版本。(缺省为当前JDK版本)\r\n\r\n```properties\r\njava.version=1.6\r\n```\r\n\r\n(4) 调试选项：\r\n\r\n如果你想知道编译后的字节码是什么样的，可以设置编译目录，目录必须预先创建，编译器会向该目录输出.class文件。\r\n\r\n编译目录缺省关闭：(缺省值不用配)\r\n\r\n```properties\r\ncompile.directory=\r\n```\r\n\r\n## 8.6 输出格式化器\r\n\r\n缺省加载了日期格式化器：(缺省值不用配)\r\n\r\n```properties\r\nformatters=httl.spi.formatters.DateFormatter\r\ndate.format=yyyy-MM-dd HH:mm:ss\r\ntime.zone=\r\n```\r\n\r\n你也可以设置时区，设置后，格式化的结果会带上时区的值：(缺省为当前系统时区)\r\n\r\n```properties\r\ntime.zone=+8\r\n```\r\n\r\n你可以使用\"+=\"保留缺省的日期格式化器的同时，增加新的格式化器，多个用逗号分隔：\r\n\r\n```properties\r\nformatters+=httl.spi.formatters.NumberFormatter\r\nnumber.format=###,##0.###\r\n```\r\n\r\n你还可以设置null,true,false值的输出，\r\n\r\nnull值缺省会输出空白，true,false原样输出：(缺省值不用配)\r\n\r\n```properties\r\nnull.value=\r\ntrue.value=true\r\nfalse.value=false\r\n```\r\n\r\n比如可以配为：\r\n\r\n```properties\r\nnull.value=N/A\r\ntrue.value=yes\r\nfalse.value=no\r\n```\r\n\r\n## 8.7 输出过滤器\r\n\r\n过滤器分为两类，一类是针对模板文本的，一类是针对动态插值的。\r\n\r\n模板文本过滤会在编译的时候执行，编译时即把模板文本替换掉，不影响输出时的性能。\r\n\r\n动态插值的过滤会在输出的时候执行，需小心过滤引起性能问题，多个用逗号分隔。\r\n\r\n缺省加载了动态插值HTML过滤，防止HTML注入XSS攻击：(缺省值不用配)\r\n```properties\r\nvalue.filters=httl.spi.filters.EscapeXmlFilter\r\ntext.filters=\r\n```\r\n\r\n你可以配置在编译时将静态文本中的空白行删除：(编译时执行，不影响渲染速度)\r\n```properties\r\ntext.filters=httl.spi.filters.ClearBlankLineFilter\r\n```\r\n\r\n你也可以配置在编译时将静态文本中的连续空白符压缩成单个空格：(编译时执行，不影响渲染速度)\r\n```properties\r\ntext.filters=httl.spi.filters.CompressBlankFilter\r\n```\r\n\r\n你也可以用filters同时设置value.filters和text.filters：\r\n\r\n```properties\r\nfilters=httl.spi.filters.CompressBlankFilter\r\n```\r\n\r\n等价于：\r\n\r\n```properties\r\nvalue.filters+=httl.spi.filters.CompressBlankFilter\r\ntext.filters+=httl.spi.filters.CompressBlankFilter\r\n```\r\n\r\nHTTL缺省会移除指令所在行空白，如果需要保留，请配置：\r\n```\r\nremove.directive.blank=false\r\n```\r\n\r\n## 8.8 类型导入\r\n\r\n### 8.8.1 导入包名\r\n\r\n缺省导入了java.util包：(缺省值不用配)\r\n\r\n```properties\r\nimport.packages=java.util\r\n```\r\n\r\n这样你就可以在模板内用短类名，而不用带上全包名。\r\n\r\n你可以使用\"+=\"保留缺省导入包的同时，导入新的包，多个包用逗号分隔：\r\n\r\n```properties\r\nimport.packages+=com.foo\r\n```\r\n\r\n### 8.8.2 导入方法\r\n\r\n缺省导入DefaultMethod类中的方法：(缺省值不用配)\r\n\r\n```properties\r\nimport.methods=httl.spi.methods.DefaultMethod\r\n```\r\n\r\n你可以使用\"+=\"保留缺省方法的同时，导入新的方法，多个类用逗号分隔：\r\n\r\n```properties\r\nimport.methods+=com.foo.MyMethod\r\n```\r\n\r\n比如DefaultMethod有静态方法：(也可以是非静态方法)\r\n\r\n```java\r\npublic static String format(Date self, String format) {\r\n    return ...;\r\n}\r\npublic static char toChar(String self) {\r\n    return ...;\r\n}\r\npublic static Date now() {\r\n    return ...;\r\n}\r\n```\r\n\r\n则可以在模板中调用：\r\n\r\n```xml\r\n${date.format(\"yyyy-MM-dd\")}\r\n${str.toChar()}\r\n${now()}\r\n```\r\n\r\n原理：静态方法的第一个参数传入被操作者本身的引用，后面的参数调用时传入。\r\n\r\n如果你需要setEngine()注入引擎实例，或setXxx(String)注入配置项，可以导入非静态方法，但静态方法编译后更快。\r\n\r\n比如：\r\n\r\n```java\r\n// 将注入引擎本身\r\nprivate Engine engine;\r\npublic setEngine(Engine engine) {\r\n    this.engine = engine;\r\n}\r\n\r\n// 将注入httl.properties中input.encoding=UTF-8配置的值\r\nprivate String inputEncoding;\r\npublic setInputEncoding(String inputEncoding) {\r\n    this.inputEncoding = inputEncoding;\r\n}\r\n\r\n// 非静态方法导入\r\npublic String include(String templateName) {\r\n    return engine.getTemplate(templateName, inputEncoding).toString();\r\n}\r\n```\r\n\r\n使用方式一样：\r\n\r\n```xml\r\n${include(\"foo.httl\")}\r\n```\r\n\r\n### 8.8.3 导入宏\r\n\r\n导指定模板中的所有宏，多个模板用逗号分隔，这些宏可在其它任意模板中使用，如：\r\n\r\n```properties\r\nimport.macros=common_macros.httl\r\n```\r\n\r\n### 8.8.4 导入序列\r\n\r\n用法如：\r\n\r\n```xml\r\n<!--#foreach(weekday in \"Monday\" .. \"Sunday\")-->\r\n${weekday}\r\n<!--#end-->\r\n```\r\n\r\n缺省包含星期和月份序列：(缺省值不用配)\r\n\r\n```properties\r\nsequences=Mon Tue Wed Thu Fri Sat Sun Mon,\\\r\nMonday Tuesday Wednesday Thursday Friday Saturday Sunday Monday,\\\r\nJan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec Jan,\\\r\nJanuary February March May June July August September October November December January\r\n```\r\n\r\n你可以使用\"+=\"保留缺省序列的同时，增加新的序列，序列中的值用空格分隔，多个序列用逗号分隔：\r\n\r\n```properties\r\nsequences+=金 木 水 火 土 金\r\n```\r\n\r\n## 8.9 日志输出配置\r\n\r\n缺省使用log4j输出日志：(缺省值不用配)\r\n\r\n```properties\r\nloggers=httl.spi.loggers.Log4jLogger\r\n```\r\n\r\n如果你需要使用其它日志工具输出日志，可配置自己的适配器。\r\n\r\n比如使用JDK的日志输出：\r\n\r\n```properties\r\nloggers=httl.spi.loggers.JdkLogger\r\n```\r\n\r\n你也可以同时输出到多个日志工具：\r\n\r\n```properties\r\nloggers=httl.spi.loggers.Log4jLogger,httl.spi.loggers.JdkLogger\r\n```\r\n\r\n或者使用\"+=\"保留缺省的log4j输出的同时，增加新的输出，多个用逗号分隔：\r\n\r\n```properties\r\nloggers+=httl.spi.loggers.JdkLogger\r\n```\r\n\r\n注：当日志级别为DEBUG时，HTTL将向日志中输出编译的模板源码，方便排错。\r\n\r\n## 8.10 运行时属性\r\n\r\n缺省只从引擎配置中获取属性：(缺省值不用配)\r\n\r\n```\r\nresolvers=httl.spi.resolvers.EngineResolver\r\n```\r\n\r\n如果你是Web应用，可以配置优先从Web请求中获取运行时属性，其次再从引擎配置中获取缺省属性：\r\n\r\n```\r\nresolvers=httl.web.WebResolver,httl.spi.resolvers.EngineResolver\r\n```\r\n\r\n比如：用户的locale区域国际化信息，换上面的配置先从请求中获取，这样就可以根据用户区域设置显示不同语言。\r\n\r\n# 9.集成\r\n\r\nHTTL在MVC中的定位：\r\n\r\n![MVC](http://httl.github.com/images/httl-mvc.png)\r\n\r\nWeb应用查找httl.properties配置的顺序：\r\n\r\n(1) 首先查找/WEB-INF/web.xml中的context-param指定的配置：\r\n\r\n```xml\r\n<context-param>\r\n    <param-name>httl.properties</param-name>\r\n    <param-value>/WEB-INF/httl.properties</param-value>\r\n</context-param>\r\n```\r\n\r\n(注：如果配置路径以 / 开头则表示在Web应用目录下，否则在ClassPath下查找)\r\n\r\n(2) 如果未配置，则查找默认WEB-INF路径：/WEB-INF/httl.properties\r\n\r\n(3) 如果WEB-INF中没有，则查找ClassPath根目录：httl.properties\r\n\r\n(4) 如果ClassPath根目录也没有，则使用标准配置。\r\n\r\n## 9.1 Spring MVC 集成\r\n\r\n配置/WEB-INF/web.xml:\r\n\r\n```xml\r\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\r\n<web-app xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n\t\txmlns=\"http://java.sun.com/xml/ns/javaee\" xmlns:web=\"http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd\"\r\n\t\txsi:schemaLocation=\"http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd\"\r\n\t\tversion=\"2.5\">\r\n\r\n\t<listener>\r\n\t\t<listener-class>org.springframework.web.context.ContextLoaderListener</listener-class>\r\n\t</listener>\r\n\r\n\t<servlet>\r\n\t\t<servlet-name>springmvc</servlet-name>\r\n\t\t<servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>\r\n\t\t<load-on-startup>1</load-on-startup>\r\n\t</servlet>\r\n\r\n\t<servlet-mapping>\r\n\t\t<servlet-name>springmvc</servlet-name>\r\n\t\t<url-pattern>/*</url-pattern>\r\n\t</servlet-mapping>\r\n\r\n</web-app>\r\n```\r\n\r\n配置/WEB-INF/springmvc-servlet.xml:\r\n\r\n```xml\r\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\r\n<!DOCTYPE beans PUBLIC \"-//SPRING//DTD BEAN 2.0//EN\" \r\n    \"http://www.springframework.org/dtd/spring-beans-2.0.dtd\">\r\n<beans>\r\n    <bean id=\"viewResolver\" class=\"httl.web.springmvc.HttlViewResolver\">\r\n        <property name=\"suffix\" value=\".httl\"/>\r\n        <property name=\"contentType\" value=\"text/html; charset=UTF-8\" />\r\n    </bean>\r\n</beans>\r\n```\r\n\r\n配置/WEB-INF/httl.properties：\r\n\r\n```properties\r\nimport.packages+=com.your.domain\r\ntemplate.directory=/WEB-INF/templates\r\ni18n.basename=/WEB-INF/messages\r\ninput.encoding=UTF-8\r\noutput.encoding=UTF-8\r\n```\r\n\r\n## 9.2 Struts 集成\r\n\r\n配置/WEB-INF/web.xml:\r\n\r\n```xml\r\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\r\n<web-app xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n\t\txmlns=\"http://java.sun.com/xml/ns/javaee\" xmlns:web=\"http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd\"\r\n\t\txsi:schemaLocation=\"http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd\"\r\n\t\tversion=\"2.5\">\r\n\r\n\t<filter>\r\n\t\t<filter-name>struts</filter-name>\r\n\t\t<filter-class>org.apache.struts2.dispatcher.FilterDispatcher</filter-class>\r\n\t</filter>\r\n\t\r\n\t<filter-mapping>\r\n\t\t<filter-name>struts</filter-name>\r\n\t\t<url-pattern>/*</url-pattern>\r\n\t</filter-mapping>\r\n\r\n</web-app>\r\n```\r\n\r\n配置classpath:struts.xml:\r\n\r\n```xml\r\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>  \r\n<!DOCTYPE struts PUBLIC  \r\n    \"-//Apache Software Foundation//DTD Struts Configuration 2.0//EN\"  \r\n    \"http://struts.apache.org/dtds/struts-2.0.dtd\">\r\n<struts>\r\n    <package name=\"hello\" extends=\"httl-default\">\r\n        <action name=\"helloWorld\" class=\"com.hello.HelloWorld\">\r\n            <result type=\"httl\">/hello_world.httl</result>\r\n\t\t</action>\r\n    </package>\r\n</struts>\r\n```\r\n\r\n配置/WEB-INF/httl.properties：\r\n\r\n```properties\r\nimport.packages+=com.your.domain\r\ntemplate.directory=/WEB-INF/templates\r\ni18n.basename=/WEB-INF/messages\r\ninput.encoding=UTF-8\r\noutput.encoding=UTF-8\r\n```\r\n\r\n## 9.3 Webx 集成\r\n\r\n配置/WEB-INF/web.xml:\r\n\r\n```xml\r\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\r\n<web-app xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n\t\txmlns=\"http://java.sun.com/xml/ns/javaee\" xmlns:web=\"http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd\"\r\n\t\txsi:schemaLocation=\"http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd\"\r\n\t\tversion=\"2.5\">\r\n\r\n\t<filter>\r\n\t\t<filter-name>webx</filter-name>\r\n\t\t<filter-class>com.alibaba.citrus.webx.servlet.WebxFrameworkFilter</filter-class>\r\n\t\t<init-param>\r\n\t\t\t<param-name>excludes</param-name>\r\n\t\t\t<param-value>*.css, *.js, *.jpg, *.gif, *.png</param-value>\r\n\t\t</init-param>\r\n\t</filter>\r\n\r\n\t<filter-mapping>\r\n\t\t<filter-name>webx</filter-name>\r\n\t\t<url-pattern>/*</url-pattern>\r\n\t</filter-mapping>\r\n\r\n</web-app>\r\n```\r\n\r\n配置/WEB-INF/webx.xml:\r\n\r\n```xml\r\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\r\n<!-- Webx Root Context Configuration.  -->\r\n<beans:beans xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n    xmlns:beans=\"http://www.springframework.org/schema/beans\"\r\n    xmlns:p=\"http://www.springframework.org/schema/p\"\r\n    xmlns:services=\"http://www.alibaba.com/schema/services\"\r\n    xmlns:engines=\"http://www.alibaba.com/schema/services/template/engines\"\r\n    xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\r\n    \t\thttp://www.alibaba.com/schema/services http://localhost:8080/schema/services.xsd\r\n        \thttp://www.alibaba.com/schema/services/template/engines http://localhost:8080/schema/services/template/engines.xsd\">\r\n\r\n\t<services:template>\r\n        <engines:httl-engine />\r\n\t</services:template>\r\n\r\n</beans:beans>\r\n```\r\n\r\n配置/WEB-INF/httl.properties：\r\n\r\n```properties\r\nimport.packages+=com.your.domain\r\ntemplate.directory=/WEB-INF/templates\r\ni18n.basename=/WEB-INF/messages\r\ninput.encoding=UTF-8\r\noutput.encoding=UTF-8\r\n```\r\n\r\n## 9.4 Filter 集成\r\n\r\n你需要在你的业务Servlet中，处理完业务后，将业务参数都写到request.setAttribute()中。\r\nHttlFilter会模板目录下读取请求path加.httl后缀的模板，然后以request中的变量进行渲染。\r\n\r\n配置/WEB-INF/web.xml:\r\n\r\n```xml\r\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\r\n<web-app xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n\t\txmlns=\"http://java.sun.com/xml/ns/javaee\" xmlns:web=\"http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd\"\r\n\t\txsi:schemaLocation=\"http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd\"\r\n\t\tversion=\"2.5\">\r\n\r\n\t<servlet>\r\n\t    <servlet-name>yourservlet</servlet-name>\r\n\t    <servlet-class>com.foo.YourServlet</servlet-class>\r\n\t    <load-on-startup>1</load-on-startup>\r\n\t</servlet>\r\n\r\n\t<servlet-mapping>\r\n\t    <servlet-name>yourservlet</servlet-name>\r\n\t    <url-pattern>*.do</url-pattern>\r\n\t</servlet-mapping>\r\n\t\r\n\t<filter>\r\n\t    <filter-name>httl</filter-name>\r\n\t    <filter-class>httl.web.servlet.HttlFilter</filter-class>\r\n\t</filter>\r\n\r\n\t<filter-mapping>\r\n\t    <filter-name>httl</filter-name>\r\n\t    <url-pattern>*.do</url-pattern>\r\n\t</filter-mapping>\r\n\r\n</web-app>\r\n```\r\n\r\n配置/WEB-INF/httl.properties：\r\n\r\n```properties\r\nimport.packages+=com.your.domain\r\ntemplate.directory=/WEB-INF/templates\r\ni18n.basename=/WEB-INF/messages\r\ninput.encoding=UTF-8\r\noutput.encoding=UTF-8\r\n```\r\n\r\n## 9.5 Servlet 集成\r\n\r\n你需要在你的业务Servlet中，处理完业务后，将业务参数都写到request.setAttribute()中，\r\n并将请求forward到指定模板，比如：request.getRequestDispatcher(\"foo.httl\").forward(request, response);\r\nHttlServlet会模板目录下读取forward过来的path同名的模板，然后以request中的变量进行渲染。\r\n\r\n配置/WEB-INF/web.xml:\r\n\r\n```xml\r\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\r\n<web-app xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n\t\txmlns=\"http://java.sun.com/xml/ns/javaee\" xmlns:web=\"http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd\"\r\n\t\txsi:schemaLocation=\"http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd\"\r\n\t\tversion=\"2.5\">\r\n\r\n\t<servlet>\r\n\t    <servlet-name>yourservlet</servlet-name>\r\n\t    <servlet-class>com.foo.YourServlet</servlet-class>\r\n\t    <load-on-startup>1</load-on-startup>\r\n\t</servlet>\r\n\r\n\t<servlet-mapping>\r\n\t    <servlet-name>yourservlet</servlet-name>\r\n\t    <url-pattern>*.do</url-pattern>\r\n\t</servlet-mapping>\r\n\t\r\n\t<servlet>\r\n\t    <servlet-name>httl</servlet-name>\r\n\t    <servlet-class>httl.web.servlet.HttlServlet</servlet-class>\r\n\t    <load-on-startup>2</load-on-startup>\r\n\t</servlet>\r\n\r\n\t<servlet-mapping>\r\n\t    <servlet-name>httl</servlet-name>\r\n\t    <url-pattern>*.httl</url-pattern>\r\n\t</servlet-mapping>\r\n\r\n</web-app>\r\n```\r\n\r\n配置/WEB-INF/httl.properties：\r\n\r\n```properties\r\nimport.packages+=com.your.domain\r\ntemplate.directory=/WEB-INF/templates\r\ni18n.basename=/WEB-INF/messages\r\ninput.encoding=UTF-8\r\noutput.encoding=UTF-8\r\n```\r\n\r\n# 10.扩展\r\n\r\n## 10.1 配置注入：\r\n\r\n```java\r\npublic MyFilter implements Filter {\r\n\r\n\tprivate String outputEncoding;\r\n\r\n\t// 将注入httl.properties中的output.encoding=UTF-8配置项\r\n\tpublic void setOutputEncoding(String outputEncoding) {\r\n\t\tthis.outputEncoding = outputEncoding;\r\n\t}\r\n\r\n\tprivate Compiler compiler;\r\n\r\n\t// 将注入httl.properties中的compiler配置项\r\n\t// 并且将实例化和初始化好compiler的属性\r\n\tpublic void setCompiler(Compiler compiler) {\r\n\t\tthis.compiler = compiler;\r\n\t}\r\n\r\n\tprivate Engine engine;\r\n\r\n\t// 将注入Engine本身\r\n\tpublic void setEngine(Engine engine) {\r\n\t\tthis.engine = engine;\r\n\t}\r\n\t\r\n\t// 当属性注入完后执行\r\n\tpublic void init() {\r\n\t}\r\n\r\n\tpublic String filter(String value) {\r\n\t\t// ...\r\n\t}\r\n\r\n}\r\n```\r\n\r\n## 10.2 支持的扩展点\r\n\r\n```properties\r\n# 日志输出\r\nloggers=httl.spi.Logger\r\n\r\n# JAVA编译器\r\ncompiler=httl.spi.Compiler\r\n\r\n# 模板语法解析器\r\nparser=httl.spi.Parser\r\n\r\n# 表达式翻译器\r\ntranslator=httl.spi.Translator\r\n\r\n# 属性决策器\r\nresolvers=httl.spi.Resolver\r\n\r\n# 模板加载器\r\nloaders=httl.spi.Loader\r\n\r\n# 模板缓存\r\ntemplate.cache=java.util.Map\r\n\r\n# 表达式缓存\r\nexpression.cache=java.util.Map\r\n\r\n# 插值过滤\r\nvalue.filters=httl.spi.Filter\r\n\r\n# 静态文本过滤\r\ntext.filters=httl.spi.Filter\r\n\r\n# 插值格式化器\r\nformatters=httl.spi.Formatter\r\n\r\n# 方法扩展\r\nimport.methods=StaticMethodClass\r\n```\r\n\r\n# 11.下载\r\n\r\n## 11.1 发布包:\r\n\r\n<https://github.com/httl/httl/downloads>\r\n\r\n## 11.2 源代码:\r\n\r\n<https://github.com/httl/httl>\r\n\r\n下载源码：\r\n\r\n```bash\r\ngit clone https://github.com/httl/httl.git\r\n```\r\n\r\n编译源码：\r\n\r\n```bash\r\nmvn install -Dmaven.test.skip\r\n```\r\n\r\n生成Eclipse工程描述文件:\r\n\r\n```bash\r\nmvn eclipse:eclipse -DdownloadSources\r\n```\r\n\r\n导入Eclipse工程：\r\n\r\nEclipse -> File -> Import -> Existing Projects into Workspace -> Browse -> Finished\r\n\r\n将.httl文件以html编辑器格式打开：\r\n\r\nEclipse -> Window -> Preferences -> General -> Content Types -> Text -> HTML -> Add -> .httl\r\n\r\n## 11.3 Maven依赖:\r\n\r\n```xml\r\n<project>\r\n    <dependencies>\r\n        <dependency>\r\n            <groupId>httl</groupId>\r\n            <artifactId>httl</artifactId>\r\n            <version>1.0.3</version>\r\n            </dependency>\r\n    </dependencies>\r\n    <repositories>\r\n        <repository>\r\n            <id>httl-repository</id>\r\n            <name>Httl Repository</name>\r\n            <url>http://httl.github.com/maven</url>\r\n        </repository>\r\n    </repositories>\r\n<project>\r\n```\r\n\r\n## 11.4 运行环境\r\n\r\n[JDK1.5+](http://www.oracle.com/technetwork/java/javase/downloads/index.html)\r\n\r\n缺省配置下，HTTL不需要依赖任何三方类库即可运行。\r\n\r\n## 11.5 开源许可\r\n\r\n[Apache License 2.0](http://www.apache.org/licenses/LICENSE-2.0)\r\n\r\n```\r\n版权所有 2011-2012 HTTL开发团队\r\n \r\n根据2.0版本Apache许可证(以下简称\"许可证\")授权；\r\n根据本许可证，用户可以不使用此文件。\r\n用户可从下列网址获得许可证副本：\r\n \r\n     http://www.apache.org/licenses/LICENSE-2.0\r\n \r\n除非因适用法律要求或书面同意，\r\n根据本许可证分发的软件是基于\"按原样\"基础提供的，\r\n无任何明示的或暗示的保证或条件。\r\n详见根据本许可证许可下特定语言的管辖权限和限制。\r\n```\r\n\r\n# 12.变更\r\n\r\n## 12.1 HTTL 0.1.0 (2011-09-13)\r\n\r\n```\r\n第一个版本，基本功能实现，HTML属性语法解析。\r\n```\r\n\r\n## 12.2 HTTL 0.2.0 (2011-09-22)\r\n\r\n```\r\n1. 增加注释语法并设为缺省，如：<!--#if(...)--> \r\n2. 支持热加载，当文件变更时，自动重新加载，配置：reloadable=true \r\n3. 支持启动时预编译，配置：precompiled=true \r\n4. 异常信息显示出错位置周边内容，更容易排错 \r\n5. 支持注释块，不解释块，特殊符转义，如：\\#, \\$ \r\n6. 支持include,read,evaluate函数(可自行扩展)，如：${include(\"xxx.httl\")] \r\n7. 支持集合泛型参数，如：#define(List<Book> books) \r\n8. 自动空指针检测，比如：${user.role}，当user为null时不会空指针 \r\n9. 自动条件补全，比如：#if(books)等价于#if(books != null && books.size > 0) \r\n10. 支持foreach状态栈，多层foreach时，可通过${foreach.parent.index}获取上层foreach状态 \r\n11. 允许设置foreach状态变量名 \r\n12. 支持方括号数组，如：#foreach(c in [a, b, c]) \r\n13. 支持双点号序列，如：#foreach(c in a..c)或#foreach(i in 1..2)或#foreach(day in \"Monday\"..\"Sunday\") \r\n14. 支持集合或运算，选择不为空的集合，如：#foreach(book in books1 | books2) \r\n15. 支持Date类型比较，如：#if(date1 > date2) \r\n16. 支持new操作，如：${new Date()} \r\n17. 支持强制转型，如：#set(user = (User) param) \r\n18. 增加HttlServlet，支持将请求经过MVC框架处理并填充request属性后forward到HttlServlet进行页面渲染 \r\n19. 兼容JDK1.5，需配置：compiler=com.googlecode.httl.support.compilers.JavassistCompiler \r\n```\r\n\r\n## 12.3 HTTL 1.0.0 (2012-10-30)\r\n\r\n```\r\n修复问题：\r\n1. 解决foreach和if/else联合使用时状态错乱问题。\r\n2. 解决getIsXxx属性解析出错问题。\r\n3. 解决文件加载未使用指定编码问题。\r\n4. 解决部分文件流打开后未关闭问题。\r\n5. 解决迭代map出错的问题，以及Map数据的类型推断问题。\r\n\r\n新功能：\r\n6. 支持单独的macro文件定义宏方法，通过import.macros配置加载。\r\n7. 增加gt,ge,lt,le符号，在属性语法时避免表达式出现HTML标签符。\r\n\r\n兼容优化：\r\n8. 静态方法不走engine.getFunction()查找实例，直接调用类的静态方法。\r\n9. 将所有配置的获取改为setter注入，比如：setInputEncoding(String)。\r\n10. 编译Macro时直接注入到模板属性中，并增加template.getMacros()方法。\r\n11. 渲染过程不改变传入Map的状态，保证模板渲染的无副作用性，以及多次渲染的幂等性。\r\n12. 优化Profiler性能分析发现的ArrayIterator引起的性能损耗问题。\r\n13. 将文本内容不编译到字节码中，改为从缓存中获取，防止内存Perm区过大，并提供source.in.class和text.in.class开关项。\r\n\r\n不兼容优化：\r\n14. 将define指令名改成var，以免和velocity的define指令理解混淆，影响所有旧模板，用户可全文替换。\r\n15. 去掉block指令，用#set(xxx = xxxmacro())代替，影响使用block的模板。\r\n16. 将com.googlecode.httl改成httl，影响API调用，重新Ctrl+Shift+O导入一下包名即可，类名没变。\r\n17. 将com.googlecode.httl.support改成httl.spi，影响httl.properties中扩展点的配置，使用缺省配置值的，建议不要配到用户配置中。\r\n18. 将filters配置项改成了value.filters，与text.filters对应用，影响httl.properties中filter扩展点的配置。\r\n19. 将functions配置项成了import.methods，与import.packages以及import.macros对应，方便理解。\r\n20. 加号数字优先，即只要有一方为数字即换数字计算，如：\"2\" + 3，输出：5，而不是：23，如果要字符相拼双方都要为字符：\"2\" + 3.toString\r\n```\r\n\r\n## 12.4 HTTL 1.0.1 (2012-11-02)\r\n\r\n```\r\n1. 增加springmvc的ViewResolver集成。\r\n2. 增加struts的Result和TemplateEngine集成。\r\n3. 增加webx的TemplateEngine集成。\r\n4. 增加slf4j日志输出，并设为缺省。\r\n5. 增加jcl日志输出。\r\n6. 增加set(a := b)，用于将参数写回Context的参数Map中。\r\n7. 允许include传参，如：$!{include(\"aaa.httl\", [\"user\": user, \"age\": 28])}\r\n8. 优化unescapeString和unescapeHtml的性能。\r\n```\r\n\r\n## 12.5 HTTL 1.0.2 (2012-11-04)\r\n\r\n```\r\n1. 修复压测下${evaluate(\"1 + 2\")}动态编译出现大量编译问题，以及perm区增长问题，增加类及实例缓存。\r\n2. 修复压测下WrappedMap过多实例化问题，延迟到Context.getParameters()被调用时再创建。\r\n3. 修复压测下StringUtils.escapedHtml()在长字符串下会导致StringBuilder的数组拷贝问题，改为new StringBuilder(len * 2)。\r\n4. 修复压测下ClassUtils.forName()占用较多时间问题，增加Map缓存。\r\n5. 修复ClassUtils.forName()不支持多维数组问题。\r\n6. 修复压测下DateFormat查找稍慢的问题，为缺省格式的DateFormat增加独立的ThreadLocal，减少按格式查询Map缓存。\r\n7. 修复AbstractTemplate的serialize没有使用配置的字符编码问题。\r\n8. 修复a(b())一元函数解析错误的问题。\r\n9. 配置文件增加支持a=$b引用其它配置项。\r\n10. 增加ClearBlankLineFilter用于清除静态文本中的空白行。\r\n11. 增加${render($template)}动态模板求值。\r\n12. 修复Loader加载时目录拼接错误。\r\n```\r\n\r\n## 12.6 HTTL 1.0.3 (2012-11-13)\r\n\r\n```\r\n1. java.version配置项缺省改为自动获取当前JDK的版本。\r\n2. 修复precompiled注入顺序问题。\r\n3. 修复跨配置文件的$配置项引用问题。\r\n4. 增加ByteCache，减少生成字节码逻辑。\r\n5. 检查锁逃逸，ByteOutput换成UnsafeByteOutput，StringBuffer换成StringBuilder等。\r\n6. 在$!{foo}进行不过滤输出时，如果变量本身就是byte[]或String类型，直接向stream或writer输出，减少转码。\r\n7. 增强集合运算后泛型推导，比如：#foreach(book in booklist1 + booklist2)。\r\n8. 改用google的ConcurrentLinkedHashMap做LRU缓存实现。\r\n9. 支持集合相加，比如：array1 + array2, list1 + list2, map1 + map2。\r\n10. 缺省导入java.lang.Math中的静态方法。\r\n11. 增加hasResource()判断资源是否存在。\r\n12. 增加Resolver扩展接口，用于获取运行时属性，比如请求的国际化区域信息和请求的编码。\r\n13. 增加\"foo\".i18n()方法查找ResourceBunlde国际化信息，如：message_zh_CN.properties。\r\n14. 增加\"foo.httl\".locale()方法查找国际化文件名，如：foo_zh_CN.httl。\r\n```\r\n\r\n## 12.7 HTTL 1.0.4 (2012-11-25)\r\n\r\n```\r\n1. 修复生成模板类源码数组类型名称问题。\r\n2. 单引号为字符串，反单引号为char。\r\n3. 生成的模板类代码只打印在日志，不放到异常信息中。\r\n4. 自动删除指令行空白，并可通过remove.directive.blank配置。\r\n5. 多Resolver和多Loader反序查找，便于+=配置，用户配置优先。\r\n6. set支持用分号分隔多个赋值。\r\n7. foreach状态的stcak集合改成parent链。\r\n8. 清理所有Array.get()反射。\r\n9. ClassUtils增加属性反射缓存。\r\n10. 允许分开设置template.cache.capacity和expression.cache.capacity。\r\n11. 修复生成Java代码时，部分方法调用没有生成null判断。\r\n12. read,include应根据output类型自适应返回byte[]或String。\r\n13. 增加byte[]和char[]的toString处理。\r\n14. 增加string.split(char)方法。\r\n15. 增加Object弱类型参数运行时byte[]判断，以免被format()成String，再转回byte[]输出。\r\n16. 打印配置和模板加载目录INFO日志，方便排错。\r\n17. 解决Engine的properties后于init()方法赋值问题。\r\n18. 修复set重复定义变量类型，导致JdkCompiler编译失败的问题。\r\n19. 国际化信息找不到时，显示Key。\r\n20. 改为从模板相同的Loader加载国际化信息。\r\n21. 改为使用EncodingProperties加载国际化信息，用户可以直接用UTF-8文件保存国际化信息，而不需要ascii2native。\r\n22. 所有Web集成不再需要在web.xml和httl.properties中配置ServletLoader，缺省自动配置。\r\n```\r\n\r\n# 13.支持\r\n\r\n如果使用过程中遇到问题，请在下面地址提交问题：\r\n\r\nhttps://github.com/httl/httl/issues\r\n\r\n邮箱：liangfei0201 (At) gmail (Dot) com\r\n\r\n博客：http://javatar.iteye.com\r\n\r\n微博：http://weibo.com/liangfei0201\r\n"}