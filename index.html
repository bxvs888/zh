<!DOCTYPE html>
<html>
  <head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <link href='https://fonts.googleapis.com/css?family=Chivo:900' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen" />
    <link rel="stylesheet" type="text/css" href="stylesheets/pygment_trac.css" media="screen" />
    <link rel="stylesheet" type="text/css" href="stylesheets/print.css" media="print" />
    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <title>&lt;HTTL/&gt; by httl</title>
  </head>

  <body>
    <div id="container">
      <div class="inner">

        <header>
          <h1>&lt;HTTL/&gt;</h1>
          <h2>HTTL是一个适用于HTML输出的开源JAVA模板引擎.</h2>
        </header>

        <section id="downloads" class="clearfix">
          <a href="https://github.com/downloads/httl/httl/httl-1.0.1.jar" id="download-zip" class="button"><span>下载 1.0.1.jar</span></a>
          <a href="https://github.com/downloads/httl/httl/httl-1.0.1-sources.jar" id="download-tar-gz" class="button"><span>下载 1.0.1-src.jar</span></a>
          <a href="https://github.com/httl/httl" id="view-on-github" class="button"><span>查看源码仓库</span></a>
        </section>

        <hr>

        <section id="main_content">
          <h1>1.概述</h1>

<p>HTTL是一个适用于HTML输出的开源JAVA模板引擎，可用于替代JSP页面，它的指令和Velocity相似。 </p>

<h3>快速</h3>

<p>类似于JSP的原理，将模板编译成Java字节码运行，但比JSP的EL更进一步，使用强类型推导，减少运行期反射和转型，更加快速，请参见第2章的性能对比.</p>

<h3>简洁</h3>

<p>保持最简洁指令集，只保留基本的占位/注释/转义，和八个必需的控制指令，其它都降级为表达式方法实现，比如$!{include("a.httl")}。</p>

<h3>直觉</h3>

<p>语法尽可能符合HTML和JAVA开发者的直觉，指令类似于常用Velocity指令，但改进了Velocity中不符合直觉的地方，请参见第2章与Velocity的对比。</p>

<h3>友好</h3>

<p>模板自描述，在模板内声明入参变量类型，并基于入参类型推导模板内所有变量类型，使IDE能方便的实现变量方法补全提示，对开发过程友好。</p>

<h1>2.对比</h1>

<h2>2.1 性能对比</h2>

<p>性能测试类：<a href="https://github.com/httl/httl/blob/master/src/test/java/httl/test/PerformanceTest.java">PerformanceTest.java</a></p>

<table>
<tr>
<td>引擎</td>
<td>模板</td>
<td>初始化</td>
<td>编译</td>
<td>首渲染</td>
<td>十万渲染</td>
<td>每秒次数</td>
</tr>
<tr></tr>
<tr>
<td><a href="https://github.com/httl/httl/blob/master/src/test/java/httl/test/performance/JavaCase.java">java</a></td>
<td><a href="https://github.com/httl/httl/blob/master/src/test/java/httl/test/performance/Books.java">books.java</a></td>
<td>0ms</td>
<td>1ms</td>
<td>0ms/28,778byte</td>
<td>8,739ms/100,000</td>
<td>11,442/s</td>
</tr>
<tr>
<td><a href="https://github.com/httl/httl/blob/master/src/test/java/httl/test/performance/HttlCase.java">httl</a></td>
<td><a href="https://github.com/httl/httl/blob/master/src/test/resources/performance/books.httl">books.httl</a></td>
<td>88ms</td>
<td>621ms</td>
<td>3ms/28,778byte</td>
<td>9,608ms/100,000</td>
<td>10,407/s</td>
</tr>
<tr>
<td><a href="https://github.com/httl/httl/blob/master/src/test/java/httl/test/performance/VelocityCase.java">velocity</a></td>
<td><a href="https://github.com/httl/httl/blob/master/src/test/resources/performance/books.vm">books.vm</a></td>
<td>21ms</td>
<td>96ms</td>
<td>23ms/28,172byte</td>
<td>41,969ms/100,000</td>
<td>2,382/s</td>
</tr>
<td><a href="https://github.com/httl/httl/blob/master/src/test/java/httl/test/performance/FreemarkerCase.java">freemarker</a></td>
<td><a href="https://github.com/httl/httl/blob/master/src/test/resources/performance/books.ftl">books.ftl</a></td>
<td>103ms</td>
<td>121ms</td>
<td>141ms/27,571byte</td>
<td>56,192ms/100,000</td>
<td>1,779/s</td>

<tr>
<td><a href="https://github.com/httl/httl/blob/master/src/test/java/httl/test/performance/Smarty4jCase.java">smarty4j</a></td>
<td><a href="https://github.com/httl/httl/blob/master/src/test/resources/performance/books.st">books.st</a></td>
<td>2ms</td>
<td>75ms</td>
<td>18ms/29,044byte</td>
<td>65,855ms/100,000</td>
<td>1,518/s</td>
</tr>
<tr>
<td><a href="https://github.com/httl/httl/blob/master/src/test/java/httl/test/performance/BeetlCase.java">beetl</a></td>
<td><a href="https://github.com/httl/httl/blob/master/src/test/resources/performance/books.btl">books.btl</a></td>
<td>24ms</td>
<td>11ms</td>
<td>159ms/26,820byte</td>
<td>81,428ms/100,000</td>
<td>1,228/s</td>
</tr>
</table><p>环境：os: Mac OS X 10.8.2, cpu: 2 x 1.70GHz, mem: 4G, jvm: 1.7.0_09 -&gt; mem: 80M</p>

<h3>HTTL的渲染速度接近于直接用Java硬编码输出，比其它模板引擎高出10倍。</h3>

<p>HTTL用到的JDK的Compiler，编译一个类通常需要几百毫秒，比其它模板的编译要慢，但每个模板只在加载时编译一次。</p>

<p>注：不同环境的运行结果可能存在差异，以上测试数据仅供参考，你可以在自己的机器上执行测试：</p>

<div class="highlight"><pre>git clone https://github.com/httl/httl.git
<span class="nb">cd </span>httl
mvn <span class="nb">test</span> -Dtest<span class="o">=</span>httl.test.PerformanceTest
</pre></div>

<h2>2.2 优化策略</h2>

<h3>2.2.1 强类型编译，并推导关联类型</h3>

<p>对于表达式${user.name}的编译：</p>

<p>弱类型字节码生成：</p>

<div class="highlight"><pre><span class="n">Object</span> <span class="n">user</span> <span class="o">=</span> <span class="n">context</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="s">"user"</span><span class="o">);</span> <span class="c1">// 无法确定user是Map还是POJO</span>
<span class="c1">// 反射获取属性的值，而且要运行期判断是user.getName()，还是user.name字段</span>
<span class="n">Object</span> <span class="n">name</span> <span class="o">=</span> <span class="n">ReflectUtil</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">user</span><span class="o">,</span> <span class="s">"name"</span><span class="o">);</span> <span class="c1">// 接下来name也要反射</span>
</pre></div>

<p>HTTL强类型字节码生成：</p>

<div class="highlight"><pre><span class="n">User</span> <span class="n">user</span> <span class="o">=</span> <span class="o">(</span><span class="n">User</span><span class="o">)</span><span class="n">context</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="s">"user"</span><span class="o">);</span> <span class="c1">// 通过in="User user"声明类型</span>
<span class="c1">// 编译期通过User的字段类型推演name的类型，并在编译期决定使用getName()</span>
<span class="n">String</span> <span class="n">name</span> <span class="o">=</span> <span class="n">user</span><span class="o">.</span><span class="na">getName</span><span class="o">();</span>
</pre></div>

<h3>2.2.2 编译时就将文本编译成字节，加快输出</h3>

<p>文本编译：</p>

<div class="highlight"><pre><span class="n">writer</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="s">"&lt;table&gt;&lt;tr&gt;&lt;td&gt;"</span><span class="o">);</span>
<span class="n">writer</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="n">user</span><span class="o">.</span><span class="na">getName</span><span class="o">());</span>
</pre></div>

<p>二进制编译：</p>

<div class="highlight"><pre><span class="n">output</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="k">new</span> <span class="kt">byte</span><span class="o">[]</span> <span class="o">{</span><span class="mi">60</span><span class="o">,</span> <span class="mi">116</span><span class="o">,</span> <span class="mi">97</span><span class="o">,</span> <span class="mi">98</span><span class="o">,</span> <span class="mi">108</span><span class="o">,</span> <span class="mi">101</span><span class="o">,</span> <span class="mi">62</span><span class="o">,</span> <span class="mi">60</span><span class="o">,</span> <span class="mi">116</span><span class="o">,</span> <span class="mi">114</span><span class="o">,</span> <span class="mi">62</span><span class="o">,</span> <span class="mi">60</span><span class="o">,</span> <span class="mi">116</span><span class="o">,</span> <span class="mi">100</span><span class="o">,</span> <span class="mi">62</span><span class="o">});</span>
<span class="n">output</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="n">user</span><span class="o">.</span><span class="na">getName</span><span class="o">().</span><span class="na">getBytes</span><span class="o">());</span>
</pre></div>

<p>这样可以大幅度降低IO输出时将文本通过字符集编码成二进制流的速度。</p>

<p>HTTL缺省每模板同时生成两份class，在用户传入OutputStream和Writer时，执行不同的class：</p>

<div class="highlight"><pre><span class="n">template</span><span class="o">.</span><span class="na">render</span><span class="o">(</span><span class="n">paramaters</span><span class="o">,</span> <span class="n">outputStream</span><span class="o">);</span> <span class="c1">// 内部将执行二进制输出版本的Template类</span>
<span class="n">template</span><span class="o">.</span><span class="na">render</span><span class="o">(</span><span class="n">paramaters</span><span class="o">,</span> <span class="n">writer</span><span class="o">);</span> <span class="c1">// 内部将执行文本输出版本的Template类</span>
</pre></div>

<h3>2.2.3 对于赋值生成局部变量，不put回参数map</h3>

<p>比如将：</p>

<div class="highlight"><pre><span class="c">&lt;!--#set(price = price * discount / 100)--&gt;</span>
${price}
</pre></div>

<p>编译成：</p>

<div class="highlight"><pre><span class="kt">int</span> <span class="n">price</span> <span class="o">=</span> <span class="n">price</span> <span class="o">*</span> <span class="n">discount</span> <span class="o">/</span> <span class="mi">100</span><span class="o">;</span>
<span class="n">write</span><span class="o">(</span><span class="n">price</span><span class="o">);</span>
</pre></div>

<p>而不是：</p>

<div class="highlight"><pre><span class="n">context</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"price"</span><span class="o">,</span> <span class="n">price</span> <span class="o">*</span> <span class="n">discount</span> <span class="o">/</span> <span class="mi">100</span><span class="o">);</span>
<span class="n">write</span><span class="o">(</span><span class="n">context</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="s">"price"</span><span class="o">));</span>
</pre></div>

<p>这样可以大量减少参数map的put和get的调用。</p>

<h3>2.2.4 将文本不编译到字节码中，减少内存perm区占用，以及防止JIT失效：</h3>

<p>当模板的内容较大时，会导致生成的字节码也比较大，字节码运行时会放在内存perm区，导致perm区过大。
模板多时，用户可能需要不断调大perm区：java -XX:PermSize=256MB -XX:MaxPermSize=256MB</p>

<p>另外，SunJDK缺省对大于8K字节码的方法不进行JIT优化，我们常规开启的JVM是mixed模式的，
即调用量大的，将由JIT编译成本地码运行，其它在JVM内解释执行，解释执行和编译执行的速度相差10倍以上。
参见JVM的：<a href="http://hg.openjdk.java.net/jdk6/jdk6/hotspot/file/2ecd0d1194d2/src/share/vm/runtime/globals.hpp">globals.hpp</a></p>

<div class="highlight"><pre><span class="n">product</span><span class="p">(</span><span class="kt">bool</span><span class="p">,</span> <span class="n">DontCompileHugeMethods</span><span class="p">,</span> <span class="kc">true</span><span class="p">,</span>
        <span class="s">"don't compile methods &gt; HugeMethodLimit"</span><span class="p">)</span>
<span class="n">develop</span><span class="p">(</span><span class="n">intx</span><span class="p">,</span> <span class="n">HugeMethodLimit</span><span class="p">,</span>  <span class="mi">8000</span><span class="p">,</span>
        <span class="s">"don't compile methods larger than this if +DontCompileHugeMethods"</span><span class="p">)</span>
</pre></div>

<p>通过将文本不编译到字节码中，减少内存perm区占用，也能防止JIT失效。</p>

<h3>2.2.5 减少反射调用，以及基本类型装箱。</h3>

<p>因为模板输出的大量是基本类型和字符串，Httl遇到任何类似需要boxed和unboxed的地方，都会重载所有基本类型方法，以减少boxed和unboxed的处理。
比如：当输出基本类型时，需要转成String，如果使用format(Object)接口，就会将基本类型装箱。</p>

<p>反射也经常是性能瓶颈所在，比如：因为int[]不继承于Object[]，为了通用处理，改为Array.get(array, index)来获取数组的项，
导致在Profiler分析时，发现80%的CPU时间都耗在Array.get()上。</p>

<p>等等。</p>

<h2>2.3 语法对比</h2>

<p>如果你用过Velocity模板，可以查看以下对比，加深了解：</p>

<ol>
<li><p>HTTL指令必需加注释外壳，只支持&lt;!--#if(x)--&gt;，不支持#if(x)，确保不干扰HTML本身的有效源码。 </p></li>
<li><p>HTTL指令中的变量不加$符，只支持&lt;!--#foreach(book in books)--&gt;，不支持&lt;!--#foreach($book in $books)--&gt;，因为指令中没有加引号的字符串就是变量，和常规语言的语法一样，加$有点废话。 </p></li>
<li><p>HTTL占位符必需加大括号，只支持${aaa}，不支持$aaa，因为$在JavaScript中也是合法变量名符号，而${}不是，减少混淆，也防止多人开发时，有人加大括号，有人不加，干脆没得选，都加，保持一致。 </p></li>
<li><p>HTTL占位符当变量为null时输出空白串，而不像Velocity那样原样输出指令原文，即${aaa}，等价于Velocity的$!{aaa}，以免开发人员忘写感叹号，泄漏表达式源码，如需原样输出，可使用转义\${aaa}，
在HTTL中，$!{aaa}表示不对内容进行过滤，用于原样输出HTML片段。</p></li>
<li><p>HTTL支持在所有使用变量的地方，进行表达式计算，也就是你不需要像Velocity那样，先#set($j = $i + 1)，再#if($j == $m)，可以直接&lt;!--#if(i + 1 == $m)--&gt;，其它指令也一样。</p></li>
<li><p>HTTL采用扩展Class原生方法的方式，如：${"a".toChar}，而不像Velocity的Tool工具方法那样：$(StringTool.toChar("a"))，这样的调用方式更直观，更符合代码书写习惯。</p></li>
</ol><h2>2.4 指令对比</h2>

<table>
<tr>
<td>HTTL</td>
<td>Velocity</td>
<td>异同</td>
<td>功能</td>
</tr>
<tr>
<td>${xxx.yyy}</td>
<td>$xxx.yyy<br>${xxx.yyy}</td>
<td>相同</td>
<td>输出占位符</td>
</tr>
<tr>
<td>$!{xxx.yyy}</td>
<td>$!xxx.yyy<br>$!{xxx.yyy}</td>
<td>不同</td>
<td>一个是不过滤，一个是不原样输出</td>
</tr>
<tr>
<td>&lt;!--## ... --&gt;</td>
<td>## ...<br>#* ... *#</td>
<td>相似</td>
<td>不显示注释块</td>
</tr>
<tr>
<td>&lt;![CDATA[## ... ]]&gt;</td>
<td>#[[ ... ]]#</td>
<td>相似</td>
<td>不解析文本块</td>
</tr>
<tr>
<td>\# \$ \\</td>
<td>\# \$ \\</td>
<td>相同</td>
<td>特殊符转义</td>
</tr>
<tr>
<td>&lt;!--#var(Xxx xxx)--&gt;</td>
<td>不支持</td>
<td>不同</td>
<td>定义输入参数类型</td>
</tr>
<tr>
<td>&lt;!--#set(xxx = yyy)--&gt;</td>
<td>#set($xxx = $yyy)</td>
<td>相同</td>
<td>给变量赋值</td>
</tr>
<tr>
<td>&lt;!--#if(xxx == yyy)--&gt;</td>
<td>#if($xxx == $yyy)</td>
<td>相同</td>
<td>条件判断</td>
</tr>
<tr>
<td>&lt;!--#elseif(xxx == yyy)--&gt;</td>
<td>#elseif($xxx == $yyy)</td>
<td>相同</td>
<td>否则条件判断</td>
</tr>
<tr>
<td>&lt;!--#else--&gt;</td>
<td>#else</td>
<td>相同</td>
<td>否则判断</td>
</tr>
<tr>
<td>&lt;!--#end--&gt;</td>
<td>#end</td>
<td>相同</td>
<td>结束指令</td>
</tr>
<tr>
<td>&lt;!--#foreach(item in list)--&gt;</td>
<td>#foreach($item in $list)</td>
<td>相同</td>
<td>列表循环</td>
</tr>
<tr>
<td>&lt;!--#breakif(xxx == yyy)--&gt;</td>
<td>#if($xxx == $yyy) #break #end</td>
<td>相似</td>
<td>中断循环</td>
</tr>
<tr>
<td>&lt;!--#macro(xxx)--&gt;</td>
<td>#macro($xxx)</td>
<td>相似</td>
<td>宏替换，模板片断</td>
</tr>
<tr>
<td>&lt;!--#set(xxx=xxxmacro())--&gt;</td>
<td>#define($xxx)</td>
<td>相似</td>
<td>捕获块输出到变量中</td>
</tr>
<tr>
<td>$!{read("xxx.txt")}</td>
<td>#include("xxx.txt")</td>
<td>相似</td>
<td>读取文本文件内容</td>
</tr>
<tr>
<td>$!{include("xxx.httl")}</td>
<td>#parse("xxx.vm")</td>
<td>相似</td>
<td>包含另一模板输出</td>
</tr>
<tr>
<td>$!{evaluate("1 + 2")}</td>
<td>#evaluate("1 + 2")</td>
<td>相似</td>
<td>表达式求值</td>
</tr>
<tr>
<td>不支持</td>
<td>#stop</td>
<td>不同</td>
<td>停止模板解析</td>
</tr>
</table><h1>3.示例</h1>

<h2>3.1 调用示例</h2>

<p>BooksServlet.java:</p>

<div class="highlight"><pre><span class="kn">import</span> <span class="nn">httl.*</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.*</span><span class="o">;</span>

<span class="n">Map</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">Object</span><span class="o">&gt;</span> <span class="n">parameters</span> <span class="o">=</span> <span class="k">new</span> <span class="n">HashMap</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">Object</span><span class="o">&gt;();</span>
<span class="n">parameters</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"user"</span><span class="o">,</span> <span class="n">user</span><span class="o">);</span>
<span class="n">parameters</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"books"</span><span class="o">,</span> <span class="n">books</span><span class="o">);</span>

<span class="n">Engine</span> <span class="n">engine</span> <span class="o">=</span> <span class="n">Engine</span><span class="o">.</span><span class="na">getEngine</span><span class="o">();</span>
<span class="n">Template</span> <span class="n">template</span> <span class="o">=</span> <span class="n">engine</span><span class="o">.</span><span class="na">getTemplate</span><span class="o">(</span><span class="s">"books.httl"</span><span class="o">);</span>
<span class="n">template</span><span class="o">.</span><span class="na">render</span><span class="o">(</span><span class="n">parameters</span><span class="o">,</span> <span class="n">response</span><span class="o">.</span><span class="na">getWriter</span><span class="o">());</span>
</pre></div>

<h2>3.2 模板示例</h2>

<p>books.httl:</p>

<div class="highlight"><pre><span class="c">&lt;!--#var(User user, List&lt;Book&gt; books)--&gt;</span>
<span class="nt">&lt;html&gt;</span>
  <span class="nt">&lt;body&gt;</span>
    <span class="c">&lt;!--#if(user.role == "admin")--&gt;</span>
    <span class="nt">&lt;table&gt;</span>
      <span class="c">&lt;!--#foreach(book in books)--&gt;</span>
      <span class="nt">&lt;tr&gt;</span>
        <span class="nt">&lt;td&gt;</span>${book.title}<span class="nt">&lt;/td&gt;</span>
      <span class="nt">&lt;/tr&gt;</span>
      <span class="c">&lt;!--#end--&gt;</span>
    <span class="nt">&lt;/table&gt;</span>
    <span class="c">&lt;!--#end--&gt;</span>
  <span class="nt">&lt;/body&gt;</span>
<span class="nt">&lt;/html&gt;</span>
</pre></div>

<h2>3.3 配置示例</h2>

<p>httl.properties:</p>

<div class="highlight"><pre><span class="na">import.packages+</span><span class="o">=</span><span class="s">com.xxx</span>
<span class="na">template.directory</span><span class="o">=</span>
<span class="na">input.encoding</span><span class="o">=</span><span class="s">UTF-8</span>
<span class="na">output.encoding</span><span class="o">=</span><span class="s">UTF-8</span>
</pre></div>

<p>其中，+=表示追加配置，而不覆盖缺省配置。
注意，所有配置项都有缺省值，如果使用缺省值，可以不配，
更多配置参见文档第7章。</p>

<h1>4.设计</h1>

<h2>4.1 类关系</h2>

<p><img src="http://httl.github.com/images/httl-class-diagram.png" alt="类图"></p>

<p><a href="http://httl.github.com/images/httl-class-diagram.png">查看大图</a></p>

<p>分包原则：按复用的粒度分包，如果某些类总是一起被复用，则放在一个包下面。 </p>

<p>HTTL有两种用户： </p>

<ol>
<li><p>一种是模板引擎的使用者， </p></li>
<li><p>一种是模板引擎的扩展者。 </p></li>
</ol><p>每种用户所需用到的类，就是同一复用粒度的。 </p>

<p>所以在整体上划分为三层： </p>

<ol>
<li><p>API (Application Programming Interface) 直接使用者需要导入的接口。</p></li>
<li><p>SPI (Service Provider Interface)  扩展者需要导入的接口。 </p></li>
<li><p>BUILT-IN (Built-in Implementation) 内置扩展实现。 </p></li>
</ol><p>使用者API导入： </p>

<div class="highlight"><pre><span class="kn">import</span> <span class="nn">httl.*</span><span class="o">;</span>  
</pre></div>

<p>扩展者SPI导入： </p>

<div class="highlight"><pre><span class="kn">import</span> <span class="nn">httl.spi.*</span><span class="o">;</span>
</pre></div>

<h2>4.2 调用过程</h2>

<p><img src="http://httl.github.com/images/httl-sequence-diagram.png" alt="时序图"></p>

<p><a href="http://httl.github.com/images/httl-class-diagram.png">查看大图</a></p>

<p>执行过程说明：(与上图中的序号对应) </p>

<ol>
<li><p>当从引擎中获取模板时， </p></li>
<li><p>首先会在缓存查找是否已缓存，如果有缓存就直接返回， </p></li>
<li><p>如果没有，则加载模板， </p></li>
<li><p>接着进行模板语法解析， </p></li>
<li><p>在解析到表达式时，将其转译为Java表达式， </p></li>
<li><p>并对静态文本进行编译前过滤，比如删除空白等， </p></li>
<li><p>对解析后的Java代码进行编译，得到Template的具体模板实现类， </p></li>
<li><p>实例化模板实现类， </p></li>
<li><p>将模板实例写入缓存，并返回给用户， </p></li>
<li><p>当用户调用模板的渲染方法时， </p></li>
<li><p>将静态模板文本直接输出， </p></li>
<li><p>将动态占位符内容，先格式化成字符串， </p></li>
<li><p>再进行过滤，比如转义动态内容的HTML特殊符，</p></li>
<li><p>然后输出过滤后的内容。 </p></li>
</ol><h1>5.模板</h1>

<p>基于Velocity指令和Html注释:</p>

<h2>5.1 输出指令</h2>

<h3>5.1.1 过滤输出</h3>

<p>输出表达式的计算结果，并进行过滤，比如：过滤变量中的HTML标签，防止HTML注入攻击。</p>

<div class="highlight"><pre>格式：
${expression}

示例：
${user.name}
</pre></div>

<h3>5.1.2 不过滤输出</h3>

<p>原样输出表达式的计算结果，不进行任何过滤，通常用于输出HTML片段。</p>

<div class="highlight"><pre>格式：
$!{expression}

示例：
$!{body}
</pre></div>

<h3>5.2 变量定义指令</h3>

<h3>5.2.1 类型声明</h3>

<p>声明输入变量的类型，模板内部其它变量类型基于此类型推导。</p>

<div class="highlight"><pre>格式：
<span class="c">&lt;!--#var(type name, type name)--&gt;</span>

示例：
<span class="c">&lt;!--#var(User user, Book[] books)--&gt;</span>
</pre></div>

<h3>5.2.2 变量赋值</h3>

<p>将表达式的计算结果存入变量中。</p>

<div class="highlight"><pre>格式：
<span class="c">&lt;!--#set(type name = expression)--&gt;</span>

示例：
<span class="c">&lt;!--#set(price = book.price * book.discount)--&gt;</span>
</pre></div>

<p>缺省模板中set的变量，是不会回写到Context的参数Map中的。
你需要用“:=”进行赋值，才会回写到Context的参数Map中：</p>

<div class="highlight"><pre>格式：
<span class="c">&lt;!--#set(type name := expression)--&gt;</span>

示例：
<span class="c">&lt;!--#set(price := book.price * book.discount)--&gt;</span>
</pre></div>

<p>你可以通过ThreadLocal的Context.getContext().getParameters()拿到回写的变量：</p>

<div class="highlight"><pre><span class="c1">// 你可以把入参设成不可修写的Map，不会影响运行。</span>
<span class="n">Map</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">Object</span><span class="o">&gt;</span> <span class="n">parameters</span> <span class="o">=</span> <span class="n">Collections</span><span class="o">.</span><span class="na">unmodifiableMap</span><span class="o">(</span><span class="n">parameters</span><span class="o">);</span>

<span class="c1">// 传入的parameters在渲染过程中总是不会被修复，确保渲染过程无副作用，以及多次渲染的幂等性。</span>
<span class="n">template</span><span class="o">.</span><span class="na">render</span><span class="o">(</span><span class="n">parameters</span><span class="o">,</span> <span class="n">writer</span><span class="o">);</span>

<span class="c1">// 注意：这里获取到的并不是上面render参入的parameters，而是parameters的包装类。</span>
<span class="c1">// 此parameters是可写的，当模板中set回写变量时，写入该Map中。</span>
<span class="c1">// 在查询变量时，先在包装类中查找，找不到，再到原生传入的parameters中查找。</span>
<span class="n">Context</span><span class="o">.</span><span class="na">getContext</span><span class="o">().</span><span class="na">getParameters</span><span class="o">().</span><span class="na">get</span><span class="o">(</span><span class="s">"price"</span><span class="o">);</span>
</pre></div>

<h2>5.3 条件指令</h2>

<h3>5.3.1 IF条件</h3>

<p>如果条件表达式计算结果为真或非空，则输出指令所包含的块。</p>

<div class="highlight"><pre>格式：
<span class="c">&lt;!--#if(expression)--&gt;</span>

示例：
<span class="c">&lt;!--#if(user.role == "admin")--&gt;</span>
    ...
<span class="c">&lt;!--#end--&gt;</span>
</pre></div>

<h3>5.3.2 ELSEIF条件</h3>

<p>如果前面的IF条件不为真，并且当前条件表达式计算结果为真或非空，则输出指令所包含的块。</p>

<div class="highlight"><pre>格式：
<span class="c">&lt;!--#elseif(expression)--&gt;</span>

示例：
<span class="c">&lt;!--#if(user.role == "admin")--&gt;</span>
    ...
<span class="c">&lt;!--#elseif(user.role == "member")--&gt;</span>
    ...
<span class="c">&lt;!--#end--&gt;</span>
</pre></div>

<h3>5.3.3 ELSE条件</h3>

<p>如果前面的IF条件不为真，则输出指令所包含的块。</p>

<div class="highlight"><pre>格式：
<span class="c">&lt;!--#else--&gt;</span>

示例：
<span class="c">&lt;!--#if(user.role == "admin")--&gt;</span>
    ...
<span class="c">&lt;!--#else--&gt;</span>
    ...
<span class="c">&lt;!--#end--&gt;</span>
</pre></div>

<h2>5.4 迭代指令</h2>

<h3>5.4.1 集合迭代</h3>

<p>迭代表达式产生的集合，以集合中的每项值，重复输出指令所包含的块。</p>

<div class="highlight"><pre>格式：
<span class="c">&lt;!--#foreach(name in expression)--&gt;</span>

示例：
<span class="c">&lt;!--#foreach(book in books)--&gt;</span>
    ...
    ${foreach.index}
    ${foreach.size}
    ${foreach.first}
    ${foreach.last}
<span class="c">&lt;!--#end--&gt;</span>
</pre></div>

<h3>5.4.3 中断迭代</h3>

<p>当条件表达式为真或非空时，中断当前迭代过程。</p>

<div class="highlight"><pre>格式：
<span class="c">&lt;!--#breakif(expression)--&gt;</span>

示例：
<span class="c">&lt;!--#foreach(book in books)--&gt;</span>
    ...
    <span class="c">&lt;!--#breakif(foreach.index == 10)--&gt;</span>
    ...
<span class="c">&lt;!--#end--&gt;</span>
</pre></div>

<h2>5.5 宏指令</h2>

<p>将指令块封装成可复用的模板片断，在声明处不执行，在调用时再执行。</p>

<div class="highlight"><pre>格式：
<span class="c">&lt;!--#macro(name(type name, type name))--&gt;</span>

示例：
<span class="c">&lt;!--#macro(xxx(Book[] books))--&gt;</span>
    ...
<span class="c">&lt;!--#end--&gt;</span>
$!{xxx(books)}
</pre></div>

<h2>5.6 字面指令</h2>

<h3>5.6.1 注释块</h3>

<p>隐藏注释的内容，用于注解过程，或屏蔽指令内容。</p>

<div class="highlight"><pre>格式：
<span class="c">&lt;!--## content --&gt;</span>

示例：
<span class="c">&lt;!--## This is menu --&gt;</span>
</pre></div>

<h3>5.6.2 不解析块</h3>

<p>原样输出模板内容，用于输出纯文本内容。</p>

<div class="highlight"><pre>格式：
<span class="cp">&lt;![CDATA[## content ]]&gt;</span>

示例：
<span class="cp">&lt;![CDATA[## This is menu ]]&gt;</span>
</pre></div>

<h3>5.6.3 特殊符转义</h3>

<p>原样输出指令特殊符，用于输出纯文本内容。</p>

<div class="highlight"><pre>格式：
\#, \$, \\

示例：
<span class="c">&lt;!--\#xxx --&gt;</span>
\${xxx}
</pre></div>

<h1>6.表达式</h1>

<p>基于Java表达式和扩展方法。</p>

<p>支持Java所有表达式，以下只列出与Java不同的点：</p>

<ul>
<li>所有null值的操作均返回null。</li>
<li>所有实现Comparable的对象都支持比较运算符。</li>
<li>所有对象都支持逻辑与或，分别返回空值或非空值。</li>
</ul><h2>6.1 操作符表达式</h2>

<h3>6.1.1 集合操作符</h3>

<div class="highlight"><pre><span class="nl">Sequence:</span> <span class="mi">1</span><span class="o">..</span><span class="mi">3</span>
<span class="nl">List:</span> <span class="o">[</span><span class="mi">123</span><span class="o">,</span> <span class="s">"abc"</span><span class="o">]</span>
<span class="nl">Map:</span> <span class="o">[</span><span class="s">"xxx"</span><span class="o">:</span> <span class="mi">123</span><span class="o">,</span> <span class="s">"yyy"</span><span class="o">:</span> <span class="s">"abc"</span><span class="o">]</span>
</pre></div>

<h3>6.1.2 日期操作符</h3>

<div class="highlight"><pre><span class="n">date1</span> <span class="o">&gt;</span> <span class="n">date2</span>
<span class="n">date1</span> <span class="o">&gt;=</span> <span class="n">date2</span>
<span class="n">date1</span> <span class="o">&lt;</span> <span class="n">date2</span>
<span class="n">date1</span> <span class="o">&lt;=</span> <span class="n">date2</span>
</pre></div>

<h3>6.1.3 逻辑操作符</h3>

<div class="highlight"><pre><span class="c">&lt;!--#if(object)--&gt;</span>
等价于：
<span class="c">&lt;!--#if(object != null)--&gt;</span>

<span class="c">&lt;!--#if(string)--&gt;</span>
等价于：
<span class="c">&lt;!--#if(string!= null &amp;&amp; string.length() &gt; 0)--&gt;</span>

<span class="c">&lt;!--#if(list)--&gt;</span>
等价于：
<span class="c">&lt;!--#if(list != null &amp;&amp; list1.size() &gt; 0)--&gt;</span>

<span class="c">&lt;!--#foreach(item in list1 || list2)--&gt;</span>
等价于：
<span class="c">&lt;!--#foreach(item in list1 != null &amp;&amp; list1.size() &gt; 0 ? list1 : list2)--&gt;</span>
</pre></div>

<h2>6.2 函数表达式</h2>

<h3>6.2.1 转型函数</h3>

<div class="highlight"><pre><span class="n">obj</span><span class="o">.</span><span class="na">to</span><span class="o">(</span><span class="s">"com.foo.Bar"</span><span class="o">)</span>
<span class="n">num</span><span class="o">.</span><span class="na">toDate</span>
<span class="n">str</span><span class="o">.</span><span class="na">toDate</span>
<span class="n">str</span><span class="o">.</span><span class="na">toDate</span><span class="o">(</span><span class="s">"yyyy-MM-dd HH:mm:ss"</span><span class="o">)</span>
<span class="n">str</span><span class="o">.</span><span class="na">toChar</span>
<span class="n">str</span><span class="o">.</span><span class="na">toBoolean</span>
<span class="n">str</span><span class="o">.</span><span class="na">toByte</span>
<span class="n">str</span><span class="o">.</span><span class="na">toInt</span>
<span class="n">str</span><span class="o">.</span><span class="na">toLong</span>
<span class="n">str</span><span class="o">.</span><span class="na">toFloat</span>
<span class="n">str</span><span class="o">.</span><span class="na">toDouble</span>
<span class="n">str</span><span class="o">.</span><span class="na">toClass</span>
</pre></div>

<h3>6.2.2 转义函数</h3>

<div class="highlight"><pre><span class="n">str</span><span class="o">.</span><span class="na">escapeHtml</span>
<span class="n">str</span><span class="o">.</span><span class="na">escapeUrl</span>
<span class="n">str</span><span class="o">.</span><span class="na">escapeString</span>
</pre></div>

<h3>6.2.3 格式化函数</h3>

<div class="highlight"><pre><span class="n">num</span><span class="o">.</span><span class="na">format</span><span class="o">(</span><span class="s">"###,##0"</span><span class="o">)</span>
<span class="n">num</span><span class="o">.</span><span class="na">format</span><span class="o">(</span><span class="s">"###,##0.##"</span><span class="o">)</span>
<span class="n">date</span><span class="o">.</span><span class="na">format</span><span class="o">(</span><span class="s">"yyyy-MM-dd"</span><span class="o">)</span>
<span class="n">date</span><span class="o">.</span><span class="na">format</span><span class="o">(</span><span class="s">"yyyy-MM-dd HH:mm:ss"</span><span class="o">)</span>
</pre></div>

<h3>6.2.4 集合函数</h3>

<div class="highlight"><pre>array[index]
list[index]

map.key
map["key"]

<span class="c">&lt;!--#foreach(item in array)--&gt;</span>
${item.xxx}
<span class="c">&lt;!--#end--&gt;</span>

<span class="c">&lt;!--#foreach(item in list)--&gt;</span>
${item.xxx}
<span class="c">&lt;!--#end--&gt;</span>

<span class="c">&lt;!--#foreach(entry in map)--&gt;</span>
${entry.key}
${entry.value}
<span class="c">&lt;!--#end--&gt;</span>

sort(list)
<span class="c">&lt;!--#foreach(item in sort(list))--&gt;</span>
<span class="c">&lt;!--#end--&gt;</span>

cycle(item, item)
<span class="c">&lt;!--#set(colors = cycle("red", "blue", "green"))--&gt;</span>
${colors.next}
</pre></div>

<h3>6.2.5 文件函数</h3>

<div class="highlight"><pre><span class="n">include</span><span class="o">(</span><span class="s">"template.httl"</span><span class="o">)}</span>
<span class="n">include</span><span class="o">(</span><span class="s">"template.httl"</span><span class="o">,</span> <span class="s">"UTF-8"</span><span class="o">)</span>
<span class="n">include</span><span class="o">(</span><span class="n">locale</span><span class="o">(</span><span class="s">"i18n-template.httl"</span><span class="o">))</span>

<span class="n">read</span><span class="o">(</span><span class="s">"text.txt"</span><span class="o">)</span>
<span class="n">read</span><span class="o">(</span><span class="s">"text.txt"</span><span class="o">,</span> <span class="s">"UTF-8"</span><span class="o">)</span>
<span class="n">read</span><span class="o">(</span><span class="n">locale</span><span class="o">(</span><span class="s">"i18n-text.txt"</span><span class="o">))</span>
</pre></div>

<h3>6.2.6 系统函数</h3>

<div class="highlight"><pre><span class="n">now</span><span class="o">()</span>
<span class="n">random</span><span class="o">()</span>
<span class="n">uuid</span><span class="o">()</span>
</pre></div>

<h1>7.配置</h1>

<p>配置中，+=表示在缺省配置上追加配置，=表示覆盖缺省配置。</p>

<h2>7.1 模板引擎配置</h2>

<div class="highlight"><pre><span class="na">engine</span><span class="o">=</span><span class="s">httl.spi.engines.DefaultEngine</span>
<span class="na">parser</span><span class="o">=</span><span class="s">httl.spi.parsers.CommentParser</span>
<span class="na">translator</span><span class="o">=</span><span class="s">httl.spi.translators.DfaTranslator</span>
</pre></div>

<p>其中，engine负责组装，parser负责解析语法，translator负责将模板表达式翻译成java表达式。
除非你想改变语法，或优化解析性能，否则此三项不需要配置。</p>

<p>如果你喜欢HTML标签属性语法，可以配置：</p>

<div class="highlight"><pre><span class="na">parser</span><span class="o">=</span><span class="s">httl.spi.parsers.AttributeParser</span>
</pre></div>

<p>语法如：</p>

<div class="highlight"><pre><span class="nt">&lt;html</span> <span class="na">var=</span><span class="s">"User user, Book[] books"</span><span class="nt">&gt;</span>
  <span class="nt">&lt;body&gt;</span>
    <span class="nt">&lt;table</span> <span class="na">if=</span><span class="s">"user.role == 'admin'"</span><span class="nt">&gt;</span>
      <span class="nt">&lt;tr</span> <span class="na">foreach=</span><span class="s">"book in books"</span><span class="nt">&gt;</span>
        <span class="nt">&lt;td&gt;</span>${book.title}<span class="nt">&lt;/td&gt;</span>
      <span class="nt">&lt;/tr&gt;</span>
    <span class="nt">&lt;/table&gt;</span>
  <span class="nt">&lt;/body&gt;</span>
<span class="nt">&lt;/html&gt;</span>
</pre></div>

<p>如果属性和其它框架冲突，可以添加名字空间：</p>

<div class="highlight"><pre><span class="na">attribute.namespace</span><span class="o">=</span><span class="s">httl</span>
</pre></div>

<p>属性语法需要用到jericho包解析HTML标签：</p>

<p><a href="http://central.maven.org/maven2/net/htmlparser/jericho/jericho-html/3.1/jericho-html-3.1.jar">jericho-html-3.1.jar</a></p>

<div class="highlight"><pre><span class="nt">&lt;dependency&gt;</span>
    <span class="nt">&lt;groupId&gt;</span>net.htmlparser.jericho<span class="nt">&lt;/groupId&gt;</span>
    <span class="nt">&lt;artifactId&gt;</span>jericho-html<span class="nt">&lt;/artifactId&gt;</span>
    <span class="nt">&lt;version&gt;</span>3.1<span class="nt">&lt;/version&gt;</span>
<span class="nt">&lt;/dependency&gt;</span>
</pre></div>

<p>名称空间写法如：</p>

<div class="highlight"><pre><span class="nt">&lt;tr</span> <span class="na">httl:foreach=</span><span class="s">"book in books"</span> <span class="nt">/&gt;</span>
</pre></div>

<p>你可以设置foreach状态的变量名，缺省为foreach：(缺省值不用配)</p>

<div class="highlight"><pre><span class="na">foreach.status</span><span class="o">=</span><span class="s">foreach</span>
</pre></div>

<h2>7.2 模板缓存配置</h2>

<p>缺省为强缓存，即所有模板加载后全部缓存：(缺省值不用配)</p>

<div class="highlight"><pre><span class="na">cache</span><span class="o">=</span><span class="s">java.util.concurrent.ConcurrentHashMap</span>
</pre></div>

<p>如果你的模板非常之多，内存不足以缓存所有模板，可以配置为LRU缓存：</p>

<div class="highlight"><pre><span class="na">cache</span><span class="o">=</span><span class="s">httl.spi.caches.LruCache</span>
<span class="na">cache.capacity</span><span class="o">=</span><span class="s">10000</span>
</pre></div>

<p>如果不需要缓存，请设为：</p>

<div class="highlight"><pre><span class="na">cache</span><span class="o">=</span><span class="s">null</span>
</pre></div>

<h2>7.4 模板加载配置</h2>

<p>(1) 可以配置启动时预编译所有模板，会调用loader.list()扫描模板文件。</p>

<p>template.suffix用于loader.list()过滤模板文件。</p>

<p>预编译缺省关闭：(缺省值不用配)</p>

<div class="highlight"><pre><span class="na">precompiled</span><span class="o">=</span><span class="s">false</span>
<span class="na">template.suffix</span><span class="o">=</span><span class="s">.httl</span>
</pre></div>

<p>(2) 可以配置是否允许热加载，缺省为false：(缺省值不用配)</p>

<div class="highlight"><pre><span class="na">reloadable</span><span class="o">=</span><span class="s">false</span>
</pre></div>

<p>开启热加载后，模板引擎在getTemplate()时会检查文件的lastModified时间，如果比上次加载的时间新，就重新加载。</p>

<p>请注意：旧的模板不会被卸载，经常改文件会导致内存perm区越来越大，只能在开发阶段使用。</p>

<p>(3) 可以配置模板加载缺省编码，缺省为UTF-8：(缺省值不用配)</p>

<div class="highlight"><pre><span class="na">input.encoding</span><span class="o">=</span><span class="s">UTF-8</span>
</pre></div>

<h3>7.4.1 从Classpath下加载</h3>

<p>缺省从Classpath下加载，即模板放在任意jar包中：(缺省值不用配)</p>

<div class="highlight"><pre><span class="na">loaders</span><span class="o">=</span><span class="s">httl.spi.loaders.ClasspathLoader</span>
<span class="na">template.directory</span><span class="o">=</span>
</pre></div>

<h3>7.4.2 从文件加载：</h3>

<div class="highlight"><pre><span class="na">loaders</span><span class="o">=</span><span class="s">httl.spi.loaders.FileLoader</span>
<span class="na">template.directory</span><span class="o">=</span><span class="s">/home/admin/templates</span>
</pre></div>

<h3>7.4.3 从jar包中加载：</h3>

<div class="highlight"><pre><span class="na">loaders</span><span class="o">=</span><span class="s">httl.spi.loaders.JarLoader</span>
<span class="na">template.directory</span><span class="o">=</span><span class="s">/home/admin/tempaltes.jar</span>
</pre></div>

<h3>7.4.4 从zip包中加载：</h3>

<div class="highlight"><pre><span class="na">loaders</span><span class="o">=</span><span class="s">httl.spi.loaders.ZipLoader</span>
<span class="na">template.directory</span><span class="o">=</span><span class="s">/home/admin/tempaltes.zip</span>
</pre></div>

<h3>7.4.5 从指定url加载：</h3>

<div class="highlight"><pre><span class="na">loaders</span><span class="o">=</span><span class="s">httl.spi.loaders.UrlLoader</span>
<span class="na">template.directory</span><span class="o">=</span><span class="s">http://myhost/tempaltes</span>
</pre></div>

<h3>7.4.6 从war包加载：</h3>

<div class="highlight"><pre><span class="na">loaders</span><span class="o">=</span><span class="s">httl.spi.loaders.ServletLoader</span>
<span class="na">template.directory</span><span class="o">=</span><span class="s">/WEB-INF/templates</span>
</pre></div>

<p>需在web.xml中配置ServletLoader的listener：</p>

<div class="highlight"><pre><span class="nt">&lt;listener&gt;</span>
    <span class="nt">&lt;listener-class&gt;</span>httl.spi.loaders.ServletLoader<span class="nt">&lt;/listener-class&gt;</span>
<span class="nt">&lt;/listener&gt;</span>
</pre></div>

<h3>7.4.7 从内存字符串加载：</h3>

<div class="highlight"><pre><span class="na">loaders</span><span class="o">=</span><span class="s">httl.spi.loaders.StringLoader</span>
</pre></div>

<p>然后编码加入模板内容：</p>

<div class="highlight"><pre><span class="n">StringLoader</span><span class="o">.</span><span class="na">addResource</span><span class="o">(</span><span class="s">"foo.httl"</span><span class="o">,</span> <span class="s">"&lt;!--#var(User user)--&gt;${user.name}"</span><span class="o">);</span>
</pre></div>

<h3>7.4.8 从多个源加载：</h3>

<div class="highlight"><pre><span class="na">loaders</span><span class="o">=</span><span class="s">httl.spi.loaders.ClasspathLoader,httl.spi.loaders.FileLoader</span>
</pre></div>

<p>或者使用"+="保留缺省的classpath加载的同时，增加新的加载器：</p>

<div class="highlight"><pre><span class="na">loaders+</span><span class="o">=</span><span class="s">httl.spi.loaders.FileLoader</span>
</pre></div>

<h2>7.5 模板编译器</h2>

<p>用于将模板类编译成字节码，缺省使用jdk自带的编译器：(缺省值不用配)</p>

<div class="highlight"><pre><span class="na">compiler</span><span class="o">=</span><span class="s">httl.spi.compilers.JdkCompiler</span>
</pre></div>

<p>你也可以换成javassist编译：</p>

<div class="highlight"><pre><span class="na">compiler</span><span class="o">=</span><span class="s">httl.spi.compilers.JavassistCompiler</span>
</pre></div>

<p>当然，也就需要增加javassist的jar包依赖：</p>

<p><a href="http://central.maven.org/maven2/org/javassist/javassist/3.15.0-GA/javassist-3.15.0-GA.jar">javassist-3.15.0-GA.jar</a></p>

<div class="highlight"><pre><span class="nt">&lt;dependency&gt;</span>
    <span class="nt">&lt;groupId&gt;</span>org.javassist<span class="nt">&lt;/groupId&gt;</span>
    <span class="nt">&lt;artifactId&gt;</span>javassist<span class="nt">&lt;/artifactId&gt;</span>
    <span class="nt">&lt;version&gt;</span>3.15.0-GA<span class="nt">&lt;/version&gt;</span>
<span class="nt">&lt;/dependency&gt;</span>
</pre></div>

<p>(1) 输出选项：</p>

<p>如果设置output.stream=true，在编译期就会将模板文件转换成byte[]数据，
在输出时，直接向OutputStream中输出byte[]流，以免运行期每次输出都要转一次。</p>

<p>缺省全部开启：(缺省值不用配)</p>

<div class="highlight"><pre><span class="na">output.stream</span><span class="o">=</span><span class="s">true</span>
<span class="na">output.writer</span><span class="o">=</span><span class="s">true</span>
</pre></div>

<p>如果output.stream和output.writer同时开启，每份模板将编译成两份class，并返回自适应Template代理类。
当用户调用template.render(Map,OutputStream)时，实际执行输出byte[]的Template类，
当用户调用template.render(Map,Writer)时，实际执行输出String的Template类。</p>

<p>如果output.stream和output.writer同时关闭，只生成writer模板，相当于只开启output.writer。</p>

<p>注意：
如果只开启output.stream=true，必须用template.render(Map,OutputStream)，否则数据转换会导致性能更低。
如果只开启output.writer=true，必须用template.render(Map,Writer)，否则数据转换会导致性能更低。</p>

<p>如果你从来不传入OutputStream或Writer，请关闭相应配置开关，减少编译开销。</p>

<p>(2) 内存选项：</p>

<p>缺省将模板源码和模板文本都不编译到字节码中：(缺省值不用配)</p>

<div class="highlight"><pre><span class="na">source.in.class</span><span class="o">=</span><span class="s">false</span>
<span class="na">text.in.class</span><span class="o">=</span><span class="s">false</span>
</pre></div>

<p>它通过一个Map缓存做中介，把模板源码和模板文本都放到了runtime属性中，以节省内存perm区大小。</p>

<p>编译到字节码中，在读取时可以会稍快，但不建议改变此选项。</p>

<p>(3) 版本选项：</p>

<p>java版本的配置会影响字节码生成的版本。</p>

<div class="highlight"><pre><span class="na">java.version</span><span class="o">=</span><span class="s">1.6</span>
</pre></div>

<p>(4) 调试选项：</p>

<p>如果你想知道编译后的字节码是什么样的，可以开启debug模式，并设置编译目录，编译器会向指定目录输出.class文件。</p>

<p>调试缺省关闭：(缺省值不用配)</p>

<div class="highlight"><pre><span class="na">debug</span><span class="o">=</span><span class="s">false</span>
<span class="na">compile.directory</span><span class="o">=</span>
</pre></div>

<h2>7.6 输出格式化器</h2>

<p>缺省加载了日期格式化器：(缺省值不用配)</p>

<div class="highlight"><pre><span class="na">formatters</span><span class="o">=</span><span class="s">httl.spi.formatters.DateFormatter</span>
<span class="na">date.format</span><span class="o">=</span><span class="s">yyyy-MM-dd HH:mm:ss</span>
<span class="na">time.zone</span><span class="o">=</span>
</pre></div>

<p>你也可以设置时区，设置后，格式化的结果会带上时区的值：(缺省为当前系统时区)</p>

<div class="highlight"><pre><span class="na">time.zone</span><span class="o">=</span><span class="s">+8</span>
</pre></div>

<p>你可以使用"+="保留缺省的日期格式化器的同时，增加新的格式化器：</p>

<div class="highlight"><pre><span class="na">formatters+</span><span class="o">=</span><span class="s">httl.spi.formatters.NumberFormatter</span>
<span class="na">number.format</span><span class="o">=</span><span class="s">###,##0.###</span>
</pre></div>

<p>你还可以设置null,true,false值的输出，</p>

<p>null值缺省会输出空白，true,false原样输出：(缺省值不用配)</p>

<div class="highlight"><pre><span class="na">null.value</span><span class="o">=</span>
<span class="na">true.value</span><span class="o">=</span><span class="s">true</span>
<span class="na">false.value</span><span class="o">=</span><span class="s">false</span>
</pre></div>

<p>比如可以配为：</p>

<div class="highlight"><pre><span class="na">null.value</span><span class="o">=</span><span class="s">N/A</span>
<span class="na">true.value</span><span class="o">=</span><span class="s">yes</span>
<span class="na">false.value</span><span class="o">=</span><span class="s">no</span>
</pre></div>

<h2>7.7 输出过滤器</h2>

<p>过滤器分为两类，一类是针对模板文本的，一类是针对动态插值的。</p>

<p>模板文本过滤会在编译的时候执行，编译时即把模板文本替换掉，不影响输出时的性能。</p>

<p>动态插值的过滤会在输出的时候执行，需小心过滤引起性能问题。</p>

<p>缺省加载了动态插值HTML过滤，防止HTML注入攻击：(缺省值不用配)</p>

<div class="highlight"><pre><span class="na">value.filters</span><span class="o">=</span><span class="s">httl.spi.filters.EscapeHtmlFilter</span>
<span class="na">text.filters</span><span class="o">=</span>
</pre></div>

<p>比如你可以设置在编译时压缩模板文本的空白符：</p>

<div class="highlight"><pre><span class="c"># 将连续的空白符压缩成单个空格</span>
<span class="na">text.filters</span><span class="o">=</span><span class="s">httl.spi.filters.CompressBlankFilter</span>

<span class="c"># 去掉所有空白符</span>
<span class="na">text.filters</span><span class="o">=</span><span class="s">httl.spi.filters.ClearBlankFilter</span>
</pre></div>

<p>你可以用filters同时设置value.filters和text.filters：</p>

<div class="highlight"><pre><span class="na">filters</span><span class="o">=</span><span class="s">httl.spi.filters.CompressBlankFilter</span>
</pre></div>

<p>等价于：</p>

<div class="highlight"><pre><span class="na">value.filters+</span><span class="o">=</span><span class="s">httl.spi.filters.CompressBlankFilter</span>
<span class="na">text.filters+</span><span class="o">=</span><span class="s">httl.spi.filters.CompressBlankFilter</span>
</pre></div>

<h2>7.8 类型导入</h2>

<h3>7.8.1 导入包名</h3>

<div class="highlight"><pre><span class="na">import.packages</span><span class="o">=</span><span class="s">java.util</span>
</pre></div>

<p>这样你就可以在模板内用短类名，而不用带上全包名。</p>

<h3>7.8.2 导入方法</h3>

<p>缺省导入DefaultMethod类中的方法：(缺省值不用配)</p>

<div class="highlight"><pre><span class="na">import.methods</span><span class="o">=</span><span class="s">httl.spi.methods.DefaultMethod</span>
</pre></div>

<p>你可以使用"+="保留缺省方法的同时，导入新的方法：</p>

<div class="highlight"><pre><span class="na">import.methods+</span><span class="o">=</span><span class="s">com.foo.MyMethod</span>
</pre></div>

<p>比如DefaultMethod有静态方法：(也可以是非静态方法)</p>

<div class="highlight"><pre><span class="kd">public</span> <span class="kd">static</span> <span class="n">String</span> <span class="nf">format</span><span class="o">(</span><span class="n">Date</span> <span class="n">self</span><span class="o">,</span> <span class="n">String</span> <span class="n">format</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="o">...;</span>
<span class="o">}</span>
<span class="kd">public</span> <span class="kd">static</span> <span class="kt">char</span> <span class="nf">toChar</span><span class="o">(</span><span class="n">String</span> <span class="n">self</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="o">...;</span>
<span class="o">}</span>
<span class="kd">public</span> <span class="kd">static</span> <span class="n">Date</span> <span class="nf">now</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">return</span> <span class="o">...;</span>
<span class="o">}</span>
</pre></div>

<p>则可以在模板中调用：</p>

<div class="highlight"><pre>${date.format("yyyy-MM-dd")}
${str.toChar()}
${now()}
</pre></div>

<p>原理：静态方法的第一个参数传入被操作者本身的引用，后面的参数调用时传入。</p>

<p>如果你需要setEngine()注入引擎实例，或setXxx(String)注入配置项，可以导入非静态方法，但静态方法编译后更快。</p>

<p>比如：</p>

<div class="highlight"><pre><span class="c1">// 将注入引擎本身</span>
<span class="kd">private</span> <span class="n">Engine</span> <span class="n">engine</span><span class="o">;</span>
<span class="kd">public</span> <span class="nf">setEngine</span><span class="o">(</span><span class="n">Engine</span> <span class="n">engine</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">this</span><span class="o">.</span><span class="na">engine</span> <span class="o">=</span> <span class="n">engine</span><span class="o">;</span>
<span class="o">}</span>

<span class="c1">// 将注入httl.properties中input.encoding=UTF-8配置的值</span>
<span class="kd">private</span> <span class="n">String</span> <span class="n">inputEncoding</span><span class="o">;</span>
<span class="kd">public</span> <span class="nf">setInputEncoding</span><span class="o">(</span><span class="n">String</span> <span class="n">inputEncoding</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">this</span><span class="o">.</span><span class="na">inputEncoding</span> <span class="o">=</span> <span class="n">inputEncoding</span><span class="o">;</span>
<span class="o">}</span>

<span class="c1">// 非静态方法导入</span>
<span class="kd">public</span> <span class="n">String</span> <span class="nf">include</span><span class="o">(</span><span class="n">String</span> <span class="n">templateName</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="n">engine</span><span class="o">.</span><span class="na">getTemplate</span><span class="o">(</span><span class="n">templateName</span><span class="o">,</span> <span class="n">inputEncoding</span><span class="o">).</span><span class="na">toString</span><span class="o">();</span>
<span class="o">}</span>
</pre></div>

<p>使用方式一样：</p>

<div class="highlight"><pre>${include("foo.httl")}
</pre></div>

<h3>7.8.3 导入宏</h3>

<div class="highlight"><pre><span class="na">import.macros</span><span class="o">=</span>
</pre></div>

<h3>7.8.4 导入序列</h3>

<p>用法如：</p>

<div class="highlight"><pre><span class="c">&lt;!--#foreach(weekday in "Monday" .. "Sunday")--&gt;</span>
${weekday}
<span class="c">&lt;!--#end--&gt;</span>
</pre></div>

<p>缺省包含星期和月份序列：(缺省值不用配)</p>

<div class="highlight"><pre><span class="na">sequences</span><span class="o">=</span><span class="s">Mon Tue Wed Thu Fri Sat Sun Mon,\</span>
<span class="s">Monday Tuesday Wednesday Thursday Friday Saturday Sunday Monday,\</span>
<span class="s">Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec Jan,\</span>
<span class="s">January February March May June July August September October November December January</span>
</pre></div>

<p>你可以使用"+="保留缺省序列的同时，增加新的序列：</p>

<div class="highlight"><pre><span class="na">sequences+</span><span class="o">=</span><span class="s">金 木 水 火 土 金</span>
</pre></div>

<h2>7.9 日志输出配置</h2>

<p>缺省使用log4j输出日志：(缺省值不用配)</p>

<div class="highlight"><pre><span class="na">loggers</span><span class="o">=</span><span class="s">httl.spi.loggers.Log4jLogger</span>
</pre></div>

<p>如果你需要使用其它日志工具输出日志，可配置自己的适配器。</p>

<p>比如使用JDK的日志输出：</p>

<div class="highlight"><pre><span class="na">loggers</span><span class="o">=</span><span class="s">httl.spi.loggers.JdkLogger</span>
</pre></div>

<p>你也可以同时输出到多个日志工具：</p>

<div class="highlight"><pre><span class="na">loggers</span><span class="o">=</span><span class="s">httl.spi.loggers.Log4jLogger,httl.spi.loggers.JdkLogger</span>
</pre></div>

<p>或者使用"+="保留缺省的log4j输出的同时，增加新的输出：</p>

<div class="highlight"><pre><span class="na">loggers+</span><span class="o">=</span><span class="s">httl.spi.loggers.JdkLogger</span>
</pre></div>

<h1>8.集成</h1>

<p>HTTL在MVC中的定位：</p>

<p><img src="http://httl.github.com/images/httl-mvc.png" alt="MVC"></p>

<p><a href="http://httl.github.com/images/httl-mvc.png">查看大图</a></p>

<ol>
<li>Web应用需要配置ServletLoader加载模板：(所有Web集成通用)</li>
</ol><p>web.xml:</p>

<div class="highlight"><pre><span class="nt">&lt;listener&gt;</span>
    <span class="nt">&lt;listener-class&gt;</span>httl.spi.loaders.ServletLoader<span class="nt">&lt;/listener-class&gt;</span>
<span class="nt">&lt;/listener&gt;</span>
</pre></div>

<p>httl.properties：</p>

<div class="highlight"><pre><span class="na">loaders</span><span class="o">=</span><span class="s">httl.spi.loaders.ServletLoader</span>
</pre></div>

<ol>
<li>Web应用查找httl.properties配置的顺序：(所有Web集成通用)</li>
</ol><p>(1) 首先查找/WEB-INF/web.xml中的context-param，如：</p>

<div class="highlight"><pre><span class="nt">&lt;context-param&gt;</span>
    <span class="nt">&lt;param-name&gt;</span>httl.properties<span class="nt">&lt;/param-name&gt;</span>
    <span class="nt">&lt;param-value&gt;</span>/WEB-INF/httl.properties<span class="nt">&lt;/param-value&gt;</span>
<span class="nt">&lt;/context-param&gt;</span>
</pre></div>

<p>(注：如果配置路径以 / 开头则表示在web应用目录下，否则在ClassPath下查找)</p>

<p>(2) 如果未配置，则查找默认WEB-INF路径：/WEB-INF/httl.properties</p>

<p>(3) 如果WEB-INF中没有，则查找ClassPath根目录：httl.properties</p>

<p>(4) 如果ClassPath根目录也没有，则使用标准配置。</p>

<h2>8.1 Spring MVC 集成</h2>

<p>配置/WEB-INF/web.xml:</p>

<div class="highlight"><pre><span class="cp">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span>
<span class="nt">&lt;web-app</span> <span class="na">xmlns:xsi=</span><span class="s">"http://www.w3.org/2001/XMLSchema-instance"</span>
        <span class="na">xmlns=</span><span class="s">"http://java.sun.com/xml/ns/javaee"</span> <span class="na">xmlns:web=</span><span class="s">"http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd"</span>
        <span class="na">xsi:schemaLocation=</span><span class="s">"http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd"</span>
        <span class="na">version=</span><span class="s">"2.5"</span><span class="nt">&gt;</span>

    <span class="nt">&lt;listener&gt;</span>
        <span class="nt">&lt;listener-class&gt;</span>httl.spi.loaders.ServletLoader<span class="nt">&lt;/listener-class&gt;</span>
    <span class="nt">&lt;/listener&gt;</span>

    <span class="nt">&lt;listener&gt;</span>
        <span class="nt">&lt;listener-class&gt;</span>org.springframework.web.context.ContextLoaderListener<span class="nt">&lt;/listener-class&gt;</span>
    <span class="nt">&lt;/listener&gt;</span>

    <span class="nt">&lt;servlet&gt;</span>
        <span class="nt">&lt;servlet-name&gt;</span>springmvc<span class="nt">&lt;/servlet-name&gt;</span>
        <span class="nt">&lt;servlet-class&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="nt">&lt;/servlet-class&gt;</span>
        <span class="nt">&lt;load-on-startup&gt;</span>1<span class="nt">&lt;/load-on-startup&gt;</span>
    <span class="nt">&lt;/servlet&gt;</span>

    <span class="nt">&lt;servlet-mapping&gt;</span>
        <span class="nt">&lt;servlet-name&gt;</span>springmvc<span class="nt">&lt;/servlet-name&gt;</span>
        <span class="nt">&lt;url-pattern&gt;</span>/*<span class="nt">&lt;/url-pattern&gt;</span>
    <span class="nt">&lt;/servlet-mapping&gt;</span>

<span class="nt">&lt;/web-app&gt;</span>
</pre></div>

<p>配置/WEB-INF/springmvc-servlet.xml:</p>

<div class="highlight"><pre><span class="cp">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span>
<span class="cp">&lt;!DOCTYPE beans PUBLIC "-//SPRING//DTD BEAN 2.0//EN" </span>
<span class="cp">    "http://www.springframework.org/dtd/spring-beans-2.0.dtd"&gt;</span>
<span class="nt">&lt;beans&gt;</span>
    <span class="nt">&lt;bean</span> <span class="na">id=</span><span class="s">"viewResolver"</span> <span class="na">class=</span><span class="s">"httl.web.springmvc.HttlViewResolver"</span><span class="nt">&gt;</span>
        <span class="nt">&lt;property</span> <span class="na">name=</span><span class="s">"suffix"</span> <span class="na">value=</span><span class="s">".httl"</span><span class="nt">/&gt;</span>
        <span class="nt">&lt;property</span> <span class="na">name=</span><span class="s">"contentType"</span> <span class="na">value=</span><span class="s">"text/html; charset=UTF-8"</span> <span class="nt">/&gt;</span>
    <span class="nt">&lt;/bean&gt;</span>
<span class="nt">&lt;/beans&gt;</span>
</pre></div>

<p>配置/WEB-INF/httl.properties：</p>

<div class="highlight"><pre><span class="na">loaders</span><span class="o">=</span><span class="s">httl.spi.loaders.ServletLoader</span>
<span class="na">template.directory</span><span class="o">=</span><span class="s">/WEB-INF/templates</span>
<span class="na">input.encoding</span><span class="o">=</span><span class="s">UTF-8</span>
<span class="na">output.encoding</span><span class="o">=</span><span class="s">UTF-8</span>
</pre></div>

<h2>8.2 Struts 集成</h2>

<p>配置/WEB-INF/web.xml:</p>

<div class="highlight"><pre><span class="cp">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span>
<span class="nt">&lt;web-app</span> <span class="na">xmlns:xsi=</span><span class="s">"http://www.w3.org/2001/XMLSchema-instance"</span>
        <span class="na">xmlns=</span><span class="s">"http://java.sun.com/xml/ns/javaee"</span> <span class="na">xmlns:web=</span><span class="s">"http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd"</span>
        <span class="na">xsi:schemaLocation=</span><span class="s">"http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd"</span>
        <span class="na">version=</span><span class="s">"2.5"</span><span class="nt">&gt;</span>

    <span class="nt">&lt;listener&gt;</span>
        <span class="nt">&lt;listener-class&gt;</span>httl.spi.loaders.ServletLoader<span class="nt">&lt;/listener-class&gt;</span>
    <span class="nt">&lt;/listener&gt;</span>

    <span class="nt">&lt;filter&gt;</span>
        <span class="nt">&lt;filter-name&gt;</span>struts<span class="nt">&lt;/filter-name&gt;</span>
        <span class="nt">&lt;filter-class&gt;</span>org.apache.struts2.dispatcher.FilterDispatcher<span class="nt">&lt;/filter-class&gt;</span>
    <span class="nt">&lt;/filter&gt;</span>

    <span class="nt">&lt;filter-mapping&gt;</span>
        <span class="nt">&lt;filter-name&gt;</span>struts<span class="nt">&lt;/filter-name&gt;</span>
        <span class="nt">&lt;url-pattern&gt;</span>/*<span class="nt">&lt;/url-pattern&gt;</span>
    <span class="nt">&lt;/filter-mapping&gt;</span>

<span class="nt">&lt;/web-app&gt;</span>
</pre></div>

<p>配置classpath:struts.xml:</p>

<div class="highlight"><pre><span class="cp">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span>  
<span class="cp">&lt;!DOCTYPE struts PUBLIC  </span>
<span class="cp">    "-//Apache Software Foundation//DTD Struts Configuration 2.0//EN"  </span>
<span class="cp">    "http://struts.apache.org/dtds/struts-2.0.dtd"&gt;</span>
<span class="nt">&lt;struts&gt;</span>
    <span class="nt">&lt;package</span> <span class="na">name=</span><span class="s">"hello"</span> <span class="na">extends=</span><span class="s">"httl-default"</span><span class="nt">&gt;</span>
        <span class="nt">&lt;action</span> <span class="na">name=</span><span class="s">"helloWorld"</span> <span class="na">class=</span><span class="s">"com.hello.HelloWorld"</span><span class="nt">&gt;</span>
            <span class="nt">&lt;result</span> <span class="na">type=</span><span class="s">"httl"</span><span class="nt">&gt;</span>/hello_world.httl<span class="nt">&lt;/result&gt;</span>
        <span class="nt">&lt;/action&gt;</span>
    <span class="nt">&lt;/package&gt;</span>
<span class="nt">&lt;/struts&gt;</span>
</pre></div>

<p>配置/WEB-INF/httl.properties：</p>

<div class="highlight"><pre><span class="na">loaders</span><span class="o">=</span><span class="s">httl.spi.loaders.ServletLoader</span>
<span class="na">template.directory</span><span class="o">=</span><span class="s">/WEB-INF/templates</span>
<span class="na">input.encoding</span><span class="o">=</span><span class="s">UTF-8</span>
<span class="na">output.encoding</span><span class="o">=</span><span class="s">UTF-8</span>
</pre></div>

<h2>8.3 Webx 集成</h2>

<p>配置/WEB-INF/web.xml:</p>

<div class="highlight"><pre><span class="cp">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span>
<span class="nt">&lt;web-app</span> <span class="na">xmlns:xsi=</span><span class="s">"http://www.w3.org/2001/XMLSchema-instance"</span>
        <span class="na">xmlns=</span><span class="s">"http://java.sun.com/xml/ns/javaee"</span> <span class="na">xmlns:web=</span><span class="s">"http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd"</span>
        <span class="na">xsi:schemaLocation=</span><span class="s">"http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd"</span>
        <span class="na">version=</span><span class="s">"2.5"</span><span class="nt">&gt;</span>

    <span class="nt">&lt;listener&gt;</span>
        <span class="nt">&lt;listener-class&gt;</span>httl.spi.loaders.ServletLoader<span class="nt">&lt;/listener-class&gt;</span>
    <span class="nt">&lt;/listener&gt;</span>

    <span class="nt">&lt;filter&gt;</span>
        <span class="nt">&lt;filter-name&gt;</span>webx<span class="nt">&lt;/filter-name&gt;</span>
        <span class="nt">&lt;filter-class&gt;</span>com.alibaba.citrus.webx.servlet.WebxFrameworkFilter<span class="nt">&lt;/filter-class&gt;</span>
        <span class="nt">&lt;init-param&gt;</span>
            <span class="nt">&lt;param-name&gt;</span>excludes<span class="nt">&lt;/param-name&gt;</span>
            <span class="nt">&lt;param-value&gt;</span>*.css, *.js, *.jpg, *.gif, *.png<span class="nt">&lt;/param-value&gt;</span>
        <span class="nt">&lt;/init-param&gt;</span>
    <span class="nt">&lt;/filter&gt;</span>

    <span class="nt">&lt;filter-mapping&gt;</span>
        <span class="nt">&lt;filter-name&gt;</span>webx<span class="nt">&lt;/filter-name&gt;</span>
        <span class="nt">&lt;url-pattern&gt;</span>/*<span class="nt">&lt;/url-pattern&gt;</span>
    <span class="nt">&lt;/filter-mapping&gt;</span>

<span class="nt">&lt;/web-app&gt;</span>
</pre></div>

<p>配置/WEB-INF/webx.xml:</p>

<div class="highlight"><pre><span class="cp">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span>
<span class="c">&lt;!-- Webx Root Context Configuration.  --&gt;</span>
<span class="nt">&lt;beans:beans</span> <span class="na">xmlns:xsi=</span><span class="s">"http://www.w3.org/2001/XMLSchema-instance"</span>
    <span class="na">xmlns:beans=</span><span class="s">"http://www.springframework.org/schema/beans"</span>
    <span class="na">xmlns:p=</span><span class="s">"http://www.springframework.org/schema/p"</span>
    <span class="na">xmlns:services=</span><span class="s">"http://www.alibaba.com/schema/services"</span>
    <span class="na">xmlns:engines=</span><span class="s">"http://www.alibaba.com/schema/services/template/engines"</span>
    <span class="na">xsi:schemaLocation=</span><span class="s">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd</span>
<span class="s">            http://www.alibaba.com/schema/services http://localhost:8080/schema/services.xsd</span>
<span class="s">            http://www.alibaba.com/schema/services/template/engines http://localhost:8080/schema/services/template/engines.xsd"</span><span class="nt">&gt;</span>

    <span class="nt">&lt;services:template&gt;</span>
        <span class="nt">&lt;engines:httl-engine</span> <span class="nt">/&gt;</span>
    <span class="nt">&lt;/services:template&gt;</span>

<span class="nt">&lt;/beans:beans&gt;</span>
</pre></div>

<p>配置/WEB-INF/httl.properties：</p>

<div class="highlight"><pre><span class="na">loaders</span><span class="o">=</span><span class="s">httl.spi.loaders.ServletLoader</span>
<span class="na">template.directory</span><span class="o">=</span><span class="s">/WEB-INF/templates</span>
<span class="na">input.encoding</span><span class="o">=</span><span class="s">UTF-8</span>
<span class="na">output.encoding</span><span class="o">=</span><span class="s">UTF-8</span>
</pre></div>

<h2>8.4 Filter 集成</h2>

<p>你需要在你的业务Servlet中，处理完业务后，将业务参数都写到request.setAttribute()中。
HttlFilter会模板目录下读取请求path加.httl后缀的模板，然后以request中的变量进行渲染。</p>

<p>配置/WEB-INF/web.xml:</p>

<div class="highlight"><pre><span class="cp">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span>
<span class="nt">&lt;web-app</span> <span class="na">xmlns:xsi=</span><span class="s">"http://www.w3.org/2001/XMLSchema-instance"</span>
        <span class="na">xmlns=</span><span class="s">"http://java.sun.com/xml/ns/javaee"</span> <span class="na">xmlns:web=</span><span class="s">"http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd"</span>
        <span class="na">xsi:schemaLocation=</span><span class="s">"http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd"</span>
        <span class="na">version=</span><span class="s">"2.5"</span><span class="nt">&gt;</span>

    <span class="nt">&lt;listener&gt;</span>
        <span class="nt">&lt;listener-class&gt;</span>httl.spi.loaders.ServletLoader<span class="nt">&lt;/listener-class&gt;</span>
    <span class="nt">&lt;/listener&gt;</span>

    <span class="nt">&lt;servlet&gt;</span>
        <span class="nt">&lt;servlet-name&gt;</span>yourservlet<span class="nt">&lt;/servlet-name&gt;</span>
        <span class="nt">&lt;servlet-class&gt;</span>com.foo.YourServlet<span class="nt">&lt;/servlet-class&gt;</span>
        <span class="nt">&lt;load-on-startup&gt;</span>1<span class="nt">&lt;/load-on-startup&gt;</span>
    <span class="nt">&lt;/servlet&gt;</span>

    <span class="nt">&lt;servlet-mapping&gt;</span>
        <span class="nt">&lt;servlet-name&gt;</span>yourservlet<span class="nt">&lt;/servlet-name&gt;</span>
        <span class="nt">&lt;url-pattern&gt;</span>*.do<span class="nt">&lt;/url-pattern&gt;</span>
    <span class="nt">&lt;/servlet-mapping&gt;</span>

    <span class="nt">&lt;filter&gt;</span>
        <span class="nt">&lt;filter-name&gt;</span>httl<span class="nt">&lt;/filter-name&gt;</span>
        <span class="nt">&lt;filter-class&gt;</span>httl.web.servlet.HttlFilter<span class="nt">&lt;/filter-class&gt;</span>
    <span class="nt">&lt;/filter&gt;</span>

    <span class="nt">&lt;filter-mapping&gt;</span>
        <span class="nt">&lt;filter-name&gt;</span>httl<span class="nt">&lt;/filter-name&gt;</span>
        <span class="nt">&lt;url-pattern&gt;</span>*.do<span class="nt">&lt;/url-pattern&gt;</span>
    <span class="nt">&lt;/filter-mapping&gt;</span>

<span class="nt">&lt;/web-app&gt;</span>
</pre></div>

<p>配置/WEB-INF/httl.properties：</p>

<div class="highlight"><pre><span class="na">loaders</span><span class="o">=</span><span class="s">httl.spi.loaders.ServletLoader</span>
<span class="na">template.directory</span><span class="o">=</span><span class="s">/WEB-INF/templates</span>
<span class="na">input.encoding</span><span class="o">=</span><span class="s">UTF-8</span>
<span class="na">output.encoding</span><span class="o">=</span><span class="s">UTF-8</span>
</pre></div>

<h2>8.5 Servlet 集成</h2>

<p>你需要在你的业务Servlet中，处理完业务后，将业务参数都写到request.setAttribute()中，
并将请求forward到指定模板，比如：request.getRequestDispatcher("foo.httl").forward(request, response);
HttlServlet会模板目录下读取forward过来的path同名的模板，然后以request中的变量进行渲染。</p>

<p>配置/WEB-INF/web.xml:</p>

<div class="highlight"><pre><span class="cp">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span>
<span class="nt">&lt;web-app</span> <span class="na">xmlns:xsi=</span><span class="s">"http://www.w3.org/2001/XMLSchema-instance"</span>
        <span class="na">xmlns=</span><span class="s">"http://java.sun.com/xml/ns/javaee"</span> <span class="na">xmlns:web=</span><span class="s">"http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd"</span>
        <span class="na">xsi:schemaLocation=</span><span class="s">"http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd"</span>
        <span class="na">version=</span><span class="s">"2.5"</span><span class="nt">&gt;</span>

    <span class="nt">&lt;listener&gt;</span>
        <span class="nt">&lt;listener-class&gt;</span>httl.spi.loaders.ServletLoader<span class="nt">&lt;/listener-class&gt;</span>
    <span class="nt">&lt;/listener&gt;</span>

    <span class="nt">&lt;servlet&gt;</span>
        <span class="nt">&lt;servlet-name&gt;</span>yourservlet<span class="nt">&lt;/servlet-name&gt;</span>
        <span class="nt">&lt;servlet-class&gt;</span>com.foo.YourServlet<span class="nt">&lt;/servlet-class&gt;</span>
        <span class="nt">&lt;load-on-startup&gt;</span>1<span class="nt">&lt;/load-on-startup&gt;</span>
    <span class="nt">&lt;/servlet&gt;</span>

    <span class="nt">&lt;servlet-mapping&gt;</span>
        <span class="nt">&lt;servlet-name&gt;</span>yourservlet<span class="nt">&lt;/servlet-name&gt;</span>
        <span class="nt">&lt;url-pattern&gt;</span>*.do<span class="nt">&lt;/url-pattern&gt;</span>
    <span class="nt">&lt;/servlet-mapping&gt;</span>

    <span class="nt">&lt;servlet&gt;</span>
        <span class="nt">&lt;servlet-name&gt;</span>httl<span class="nt">&lt;/servlet-name&gt;</span>
        <span class="nt">&lt;servlet-class&gt;</span>httl.web.servlet.HttlServlet<span class="nt">&lt;/servlet-class&gt;</span>
        <span class="nt">&lt;load-on-startup&gt;</span>2<span class="nt">&lt;/load-on-startup&gt;</span>
    <span class="nt">&lt;/servlet&gt;</span>

    <span class="nt">&lt;servlet-mapping&gt;</span>
        <span class="nt">&lt;servlet-name&gt;</span>httl<span class="nt">&lt;/servlet-name&gt;</span>
        <span class="nt">&lt;url-pattern&gt;</span>*.httl<span class="nt">&lt;/url-pattern&gt;</span>
    <span class="nt">&lt;/servlet-mapping&gt;</span>

<span class="nt">&lt;/web-app&gt;</span>
</pre></div>

<p>配置/WEB-INF/httl.properties：</p>

<div class="highlight"><pre><span class="na">loaders</span><span class="o">=</span><span class="s">httl.spi.loaders.ServletLoader</span>
<span class="na">template.directory</span><span class="o">=</span><span class="s">/WEB-INF/templates</span>
<span class="na">input.encoding</span><span class="o">=</span><span class="s">UTF-8</span>
<span class="na">output.encoding</span><span class="o">=</span><span class="s">UTF-8</span>
</pre></div>

<h1>9.下载</h1>

<h2>9.1 发布包:</h2>

<p><a href="https://github.com/httl/httl/downloads">https://github.com/httl/httl/downloads</a></p>

<h2>9.2 源代码:</h2>

<p><a href="https://github.com/httl/httl">https://github.com/httl/httl</a></p>

<p>下载源码：</p>

<div class="highlight"><pre>git clone https://github.com/httl/httl.git
</pre></div>

<p>编译源码：</p>

<div class="highlight"><pre>mvn install -Dmaven.test.skip
</pre></div>

<p>性能测试：</p>

<div class="highlight"><pre>mvn <span class="nb">test</span> -Dtest<span class="o">=</span>httl.test.PerformanceTest
</pre></div>

<p>生成Eclipse工程描述文件:</p>

<div class="highlight"><pre>mvn eclipse:eclipse -DdownloadSources
</pre></div>

<p>导入Eclipse工程：</p>

<p>Eclipse -&gt; File -&gt; Import -&gt; Existing Projects into Workspace -&gt; Browse -&gt; Finished</p>

<p>将.httl文件以html编辑器格式打开：</p>

<p>Eclipse -&gt; Window -&gt; Preferences -&gt; General -&gt; Content Types -&gt; Text -&gt; HTML -&gt; Add -&gt; .httl</p>

<h2>9.3 Maven依赖:</h2>

<div class="highlight"><pre><span class="nt">&lt;project&gt;</span>
    <span class="nt">&lt;dependencies&gt;</span>
        <span class="nt">&lt;dependency&gt;</span>
            <span class="nt">&lt;groupId&gt;</span>httl<span class="nt">&lt;/groupId&gt;</span>
            <span class="nt">&lt;artifactId&gt;</span>httl<span class="nt">&lt;/artifactId&gt;</span>
            <span class="nt">&lt;version&gt;</span>1.0.1<span class="nt">&lt;/version&gt;</span>
            <span class="nt">&lt;/dependency&gt;</span>
    <span class="nt">&lt;/dependencies&gt;</span>
    <span class="nt">&lt;repositories&gt;</span>
        <span class="nt">&lt;repository&gt;</span>
            <span class="nt">&lt;id&gt;</span>httl-repository<span class="nt">&lt;/id&gt;</span>
            <span class="nt">&lt;name&gt;</span>Httl Repository<span class="nt">&lt;/name&gt;</span>
            <span class="nt">&lt;url&gt;</span>http://httl.github.com/maven/<span class="nt">&lt;/url&gt;</span>
        <span class="nt">&lt;/repository&gt;</span>
    <span class="nt">&lt;/repositories&gt;</span>
<span class="nt">&lt;project&gt;</span>
</pre></div>

<h2>9.4 运行环境</h2>

<p><a href="http://www.oracle.com/technetwork/java/javase/downloads/index.html">JDK1.5+</a></p>

<p>缺省配置下，HTTL不需要依赖任何三方类库即可运行。</p>

<h2>9.5 开源许可</h2>

<p><a href="http://www.apache.org/licenses/LICENSE-2.0">Apache License 2.0</a></p>

<pre><code>版权所有 2011-2012 HTTL开发团队

根据2.0版本Apache许可证(以下简称"许可证")授权；
根据本许可证，用户可以不使用此文件。
用户可从下列网址获得许可证副本：

     http://www.apache.org/licenses/LICENSE-2.0

除非因适用法律要求或书面同意，
根据本许可证分发的软件是基于"按原样"基础提供的，
无任何明示的或暗示的保证或条件。
详见根据本许可证许可下特定语言的管辖权限和限制。
</code></pre>

<h1>10.变更</h1>

<h2>10.1 HTTL 0.1.0 (2011-09-13)</h2>

<pre><code>第一个版本，基本功能实现，HTML属性语法解析。
</code></pre>

<h2>10.2 HTTL 0.2.0 (2011-09-22)</h2>

<pre><code>1. 增加注释语法并设为缺省，如：&lt;!--#if(...)--&gt; 
2. 支持热加载，当文件变更时，自动重新加载，配置：reloadable=true 
3. 支持启动时预编译，配置：precompiled=true 
4. 异常信息显示出错位置周边内容，更容易排错 
5. 支持注释块，不解释块，特殊符转义，如：\#, \$ 
6. 支持include,read,evaluate函数(可自行扩展)，如：${include("xxx.httl")] 
7. 支持集合泛型参数，如：#define(List&lt;Book&gt; books) 
8. 自动空指针检测，比如：${user.role}，当user为null时不会空指针 
9. 自动条件补全，比如：#if(books)等价于#if(books != null &amp;&amp; books.size &gt; 0) 
10. 支持foreach状态栈，多层foreach时，可通过${foreach.parent.index}获取上层foreach状态 
11. 允许设置foreach状态变量名 
12. 支持方括号数组，如：#foreach(c in [a, b, c]) 
13. 支持双点号序列，如：#foreach(c in a..c)或#foreach(i in 1..2)或#foreach(day in "Monday".."Sunday") 
14. 支持集合或运算，选择不为空的集合，如：#foreach(book in books1 | books2) 
15. 支持Date类型比较，如：#if(date1 &gt; date2) 
16. 支持new操作，如：${new Date()} 
17. 支持强制转型，如：#set(user = (User) param) 
18. 增加HttlServlet，支持将请求经过MVC框架处理并填充request属性后forward到HttlServlet进行页面渲染 
19. 兼容JDK1.5，需配置：compiler=com.googlecode.httl.support.compilers.JavassistCompiler 
</code></pre>

<h2>10.3 HTTL 1.0.0 (2012-10-30)</h2>

<pre><code>修复问题：
1. 解决foreach和if/else联合使用时状态错乱问题。
2. 解决getIsXxx属性解析出错问题。
3. 解决文件加载未使用指定编码问题。
4. 解决部分文件流打开后未关闭问题。
5. 解决迭代map出错的问题，以及Map数据的类型推断问题。

新功能：
6. 支持单独的macro文件定义宏方法，通过import.macros配置加载。
7. 增加gt,ge,lt,le符号，在属性语法时避免表达式出现HTML标签符。

兼容优化：
8. 静态方法不走engine.getFunction()查找实例，直接调用类的静态方法。
9. 将所有配置的获取改为setter注入，比如：setInputEncoding(String)。
10. 编译Macro时直接注入到模板属性中，并增加template.getMacros()方法。
11. 渲染过程不改变传入Map的状态，保证模板渲染的无副作用性，以及多次渲染的幂等性。
12. 优化Profiler性能分析发现的ArrayIterator引起的性能损耗问题。
13. 将文本内容不编译到字节码中，改为从缓存中获取，防止内存Perm区过大，并提供source.in.class和text.in.class开关项。

不兼容优化：
14. 将define指令名改成var，以免和velocity的define指令理解混淆，影响所有旧模板，用户可全文替换。
15. 去掉block指令，用#set(xxx = xxxmacro())代替，影响使用block的模板。
16. 将com.googlecode.httl改成httl，影响API调用，重新Ctrl+Shift+O导入一下包名即可，类名没变。
17. 将com.googlecode.httl.support改成httl.spi，影响httl.properties中扩展点的配置，使用缺省配置值的，建议不要配到用户配置中。
18. 将filters配置项改成了value.filters，与text.filters对应用，影响httl.properties中filter扩展点的配置。
19. 将functions配置项成了import.methods，与import.packages以及import.macros对应，方便理解。
20. 加号数字优先，即只要有一方为数字即换数字计算，如："2" + 3，输出：5，而不是：23，如果要字符相拼双方都要为字符："2" + 3.toString
</code></pre>

<h2>9.4 HTTL 1.0.1 (2012-11-02)</h2>

<pre><code>1. 增加springmvc的ViewResolver集成。
2. 增加struts的Result和TemplateEngine集成。
3. 增加webx的TemplateEngine集成。
4. 增加slf4j日志输出，并设为缺省。
5. 增加jcl日志输出。
6. 增加set(a := b)，用于将参数写回Context的参数Map中。
7. 允许include传参，如：$!{include("aaa.httl", ["user": user, "age": 28])}
8. 优化unescapeString和unescapeHtml的性能。
</code></pre>
        </section>

        <footer>
          &lt;HTTL/&gt; is maintained by <a href="https://github.com/httl">httl</a><br>
          This page was generated by <a href="http://pages.github.com">GitHub Pages</a>. Tactile theme by <a href="http://twitter.com/jasonlong">Jason Long</a>.
        </footer>

<div style="position: absolute; right: 160px; top: 0px;">中文 | <a href="../en">English</a></div>
<div id="outlineIndex" style="position: absolute; left: 100px; top: 300px; display: none; width: 120px; padding: 10px; border: 1px dashed black; background-color: white;"></div>
<div id="outlineClose" style="position: absolute; left: 220px; top: 300px; display: none; color: #FF3333; cursor: pointer;" onclick="document.getElementById('outlineIndex').style.display = 'none';document.getElementById('outlineClose').style.display = 'none'">[X]</div>
<script type="text/javascript">
<!--
if (window.screen.width > 1000) {
var index = "";
var outlines = document.getElementsByTagName("h1");
for (var i = 0; i < outlines.length; i ++) {
	var outline = outlines[i];
	var name = outline.innerHTML;
    outline.outerHTML = "<a name=\"" + name + "\"></a>" + outline.outerHTML;
    index += "<a href=\"#" + name + "\">" + name + "</a><br/>"
}
document.getElementById("outlineIndex").innerHTML = index;
document.getElementById('outlineIndex').style.display = '';
document.getElementById('outlineClose').style.display = '';
var left = ((window.screen.width - 700) / 2) - 200;
if (left < 0) {
	left = 0;
}
document.getElementById('outlineIndex').style.left = left + "px";
document.getElementById('outlineClose').style.left = (left + 120) + "px";
}
-->
</script>
        
      </div>
    </div>
  </body>
</html>